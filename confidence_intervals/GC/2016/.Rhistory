round(gc2016, 3) # median: block 6 - 0.640
round(gc2017, 3) # median: block 7 - 1.062
#################
#Begin with data preparation
#Load 3-year data file for Grey Cloud Dunes
setwd("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-adaptive-capacity/VaW_W_analyses/GC")
gcdat<- read.csv("gcdata.csv")
#divide into year-specific files
gc2015<- subset(gcdat, year==2015)
gc2016<- subset(gcdat, year==2016)
gc2017<- subset(gcdat, year==2017)
#drop unused levels
gc2015<- droplevels(gc2015)
gc2016<- droplevels(gc2016)
gc2017<- droplevels(gc2017)
###################################################################################
# 1. Estimate mean expected fitness in greenhouse genration for 2015 and 2016 year#
###################################################################################
#isolate greenhouse generation from 2016 and 2017 data (only greenhouse cohort in 2015)
gh2016<- subset(gc2016, cohort=="greenhouse")
gh2016<- droplevels(gh2016)
gh2017<- subset(gc2017, cohort=="greenhouse")
gh2017<- droplevels(gh2017)
#make sure maternalID and paternalID is a factor
gc2015$maternalID<- as.factor(gc2015$maternalID)
gc2015$paternalID<- as.factor(gc2015$paternalID)
gh2016$maternalID<- as.factor(gh2016$maternalID)
gh2016$paternalID<- as.factor(gh2016$paternalID)
gh2017$maternalID<- as.factor(gh2017$maternalID)
gh2017$paternalID<- as.factor(gh2017$paternalID)
#set response variables -> these represent variables in graphical model
vars<- c("Germ","flw","total.pods", "total.pods.collected", "totalseeds")
#reshape data so that all response variables are located in a single vector in a new data
#set called "redata"
redata2015 <- reshape(gc2015, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
redata2016 <- reshape(gh2016, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
redata2017 <- reshape(gh2017, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
#Designation of fitness variable for 2015 data
fit <- grepl("totalseeds", as.character(redata2015$varb))
fit<- as.numeric(fit)
redata2015$fit <- fit
#check
with(redata2015, sort(unique(as.character(varb)[fit == 0])))
with(redata2015, sort(unique(as.character(varb)[fit == 1])))
#add a variable "root" to redata files, where value is 1
redata2015<- data.frame(redata2015, root=1)
redata2016<- data.frame(redata2016, root=1)
#make sure block, row, and position are factors
redata2015$block<- as.factor(redata2015$block)
redata2015$row<- as.factor(redata2015$row)
redata2015$position<- as.factor(redata2015$position)
redata2016$block<- as.factor(redata2016$block)
redata2016$row<- as.factor(redata2016$row)
redata2016$position<- as.factor(redata2016$position)
#save(redata2015, file="redata2015.RData")
#save(redata2016, file="redata2016.RData")
#save(redata2017, file="redata2017.RData")
#load aster package
library(aster)
#set graphical mode and dist. for fitness nodes (preds)
pred<- c(0,1,2,3,4)
fam<- c(1,1,2,2,2)
#describe dist. of preds.
sapply(fam.default(), as.character)[fam]
#fixed effect model for 2015
aout2015a<- aster(resp~varb, pred, fam, varb, id, root, data=redata2015)
aout2015<- aster(resp~varb + fit:(block), pred, fam, varb, id, root, data=redata2015)
anova(aout2015a, aout2015)
summary(aout2015, show.graph = T)
#Designate fitness variable for 2016 data
fit <- grepl("totalseeds", as.character(redata2016$varb))
fit<- as.numeric(fit)
redata2016$fit<- fit
#check
with(redata2016, sort(unique(as.character(varb)[fit == 0])))
with(redata2016, sort(unique(as.character(varb)[fit == 1])))
#Fixed-effects aster model for 2016 data
aout2016a<- aster(resp~varb , pred, fam, varb, id, root, data=redata2016)
aout2016<- aster(resp~varb + fit:(block), pred, fam, varb, id, root, data=redata2016)
anova(aout2016a, aout2016)
summary(aout2016, show.graph = T)
#Designation of fitness variable for 2017 data
fit <- grepl("totalseeds", as.character(redata2017$varb))
fit<- as.numeric(fit)
redata2017$fit <- fit
#check
with(redata2017, sort(unique(as.character(varb)[fit == 0])))
with(redata2017, sort(unique(as.character(varb)[fit == 1])))
#add a variable "root" to redata files, where value is 1
redata2017<- data.frame(redata2017, root=1)
#make sure block, row, and position are factors
redata2017$block<- as.factor(redata2017$block)
redata2017$row<- as.factor(redata2017$row)
redata2017$position<- as.factor(redata2017$position)
#check
with(redata2017, sort(unique(as.character(varb)[fit == 0])))
with(redata2017, sort(unique(as.character(varb)[fit == 1])))
#Fixed-effects aster model for 2016 data
aout2017a<- aster(resp~varb, pred, fam, varb, id, root, data=redata2017)
aout2017<- aster(resp~varb + fit:(block), pred, fam, varb, id, root, data=redata2017)
anova(aout2017a, aout2017)
summary(aout2017, show.graph = T)
##############################################################
#Estimate mean fitness for 2015, 2016 (greenhouse cohort), and 2017 (greenhouse cohort) data
#generate MLE of saturated model mean value parameter vector: mu
pout2015<- predict.aster(aout2015, se.fit=TRUE)
pout2016<- predict.aster(aout2016, se.fit=TRUE)
pout2017<- predict.aster(aout2017, se.fit=TRUE)
#make up covariate data for hypothetical
#indivs that meet "typical" criteria:
#Therefore, "make up" covariate data for hypothetical individuals
#that re comparable and obtain mean values for them
##############
#make data.frame of indivudals for each block (1-8)
fred2015 <- data.frame(block=levels(redata2015$block),
Germ=1, flw=1, total.pods=1, total.pods.collected=1, totalseeds=1,root = 1)
fred2016 <- data.frame(block=levels(redata2016$block),
Germ=1, flw=1, total.pods=1, total.pods.collected=1, totalseeds=1,root = 1)
fred2017 <- data.frame(block=levels(redata2017$block),
Germ=1, flw=1, total.pods=1, total.pods.collected=1, totalseeds=1,root = 1)
#reshape the "made up data" just as the actual data
renewdata2015 <- reshape(fred2015, varying = list(vars),
direction = "long", timevar = "varb",
times = as.factor(vars), v.names = "resp")
renewdata2016 <- reshape(fred2016, varying = list(vars),
direction = "long", timevar = "varb",
times = as.factor(vars), v.names = "resp")
renewdata2017 <- reshape(fred2017, varying = list(vars),
direction = "long", timevar = "varb",
times = as.factor(vars), v.names = "resp")
#make character string from "varb" of renewdata,
#without actual values (e.g., the layers of varb in renewdata)
layer<- gsub("[0-9]", "", as.character(renewdata2015$varb))
layer<- gsub("[0-9]", "", as.character(renewdata2016$varb))
layer<- gsub("[0-9]", "", as.character(renewdata2017$varb))
#add layer to renewdata
renewdata2015<- data.frame(renewdata2015, layer= layer)
renewdata2016<- data.frame(renewdata2016, layer= layer)
renewdata2017<- data.frame(renewdata2017, layer= layer)
# add totalseeds in new layer col of renewdata as numeric, called fit
fit<- as.numeric(layer=="totalseeds")
#add fit to renewdata
renewdata2015<- data.frame(renewdata2015, fit = fit)
renewdata2016<- data.frame(renewdata2016, fit = fit)
renewdata2017<- data.frame(renewdata2017, fit = fit)
#Generate fintess estimates and standard errors for each block
nblock<- nrow(fred2015)#all data has same number of blocks so any file will do
nnode<- length(vars)
amat<- array(0, c(nblock, nnode, nblock))
dim(amat)# makes an 8 x 5 x 8 matrix
#only want means for k'th individual that contributes to expected
#fitness, and want to add only totalseeds entries
#makes 8 , 4x8 matrices that
foo<- grepl("totalseeds", vars)
for(k in 1:nblock)
amat[k, foo, k]<- 1
#generate predicted valuses using aout object, with renewdata, and amat format
pout.amat2015<- predict(aout2015, newdata= renewdata2015, varvar= varb,
idvar= id, root = root, se.fit=TRUE, amat = amat)
pout.amat2016<- predict(aout2016, newdata= renewdata2016, varvar= varb,
idvar= id, root = root, se.fit=TRUE, amat = amat)
pout.amat2017<- predict(aout2017, newdata= renewdata2017, varvar= varb,
idvar= id, root = root, se.fit=TRUE, amat = amat)
#combine std.err with estimates, and then round
#to three decimal places
gc2015<- cbind(pout.amat2015$fit, pout.amat2015$se.fit)
gc2016<- cbind(pout.amat2016$fit, pout.amat2016$se.fit)
gc2017<- cbind(pout.amat2017$fit, pout.amat2017$se.fit)
rownames(gc2015)<- as.character(fred2015$block)
rownames(gc2016)<- as.character(fred2016$block)
rownames(gc2017)<- as.character(fred2017$block)
colnames(gc2015)<- c("Expected Fitness", "SE")
colnames(gc2016)<- c("Expected Fitness", "SE")
colnames(gc2017)<- c("Expected Fitness", "SE")
#####################################################################
#The median expected fitness for each year is used to represent     #
#the site-specific fitness. The block effects representing these    #
# fitness values will be used to calcualte and convert  Va(W)       #
#estimates from the canonical to man-value parameter scale          #
#####################################################################
round(gc2015, 3) # median: block 6 - 1.112
round(gc2016, 3) # median: block 6 - 0.640
round(gc2017, 3)
install.packages("aster")
#################
#Begin with data preparation
#Load 3-year data file for Grey Cloud Dunes
setwd("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-adaptive-capacity/VaW_W_analyses/GC")
gcdat<- read.csv("gcdata.csv")
#divide into year-specific files
gc2015<- subset(gcdat, year==2015)
gc2016<- subset(gcdat, year==2016)
gc2017<- subset(gcdat, year==2017)
#drop unused levels
gc2015<- droplevels(gc2015)
gc2016<- droplevels(gc2016)
gc2017<- droplevels(gc2017)
###################################################################################
# 1. Estimate mean expected fitness in greenhouse genration for 2015 and 2016 year#
###################################################################################
#isolate greenhouse generation from 2016 and 2017 data (only greenhouse cohort in 2015)
gh2016<- subset(gc2016, cohort=="greenhouse")
gh2016<- droplevels(gh2016)
gh2017<- subset(gc2017, cohort=="greenhouse")
gh2017<- droplevels(gh2017)
#make sure maternalID and paternalID is a factor
gc2015$maternalID<- as.factor(gc2015$maternalID)
gc2015$paternalID<- as.factor(gc2015$paternalID)
gh2016$maternalID<- as.factor(gh2016$maternalID)
gh2016$paternalID<- as.factor(gh2016$paternalID)
gh2017$maternalID<- as.factor(gh2017$maternalID)
gh2017$paternalID<- as.factor(gh2017$paternalID)
#set response variables -> these represent variables in graphical model
vars<- c("Germ","flw","total.pods", "total.pods.collected", "totalseeds")
#reshape data so that all response variables are located in a single vector in a new data
#set called "redata"
redata2015 <- reshape(gc2015, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
redata2016 <- reshape(gh2016, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
redata2017 <- reshape(gh2017, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
#Designation of fitness variable for 2015 data
fit <- grepl("totalseeds", as.character(redata2015$varb))
fit<- as.numeric(fit)
redata2015$fit <- fit
#check
with(redata2015, sort(unique(as.character(varb)[fit == 0])))
with(redata2015, sort(unique(as.character(varb)[fit == 1])))
#add a variable "root" to redata files, where value is 1
redata2015<- data.frame(redata2015, root=1)
redata2016<- data.frame(redata2016, root=1)
#make sure block, row, and position are factors
redata2015$block<- as.factor(redata2015$block)
redata2015$row<- as.factor(redata2015$row)
redata2015$position<- as.factor(redata2015$position)
redata2016$block<- as.factor(redata2016$block)
redata2016$row<- as.factor(redata2016$row)
redata2016$position<- as.factor(redata2016$position)
#save(redata2015, file="redata2015.RData")
#save(redata2016, file="redata2016.RData")
#save(redata2017, file="redata2017.RData")
#load aster package
library(aster)
#set graphical mode and dist. for fitness nodes (preds)
pred<- c(0,1,2,3,4)
fam<- c(1,1,2,2,2)
#describe dist. of preds.
sapply(fam.default(), as.character)[fam]
#fixed effect model for 2015
aout2015a<- aster(resp~varb, pred, fam, varb, id, root, data=redata2015)
aout2015<- aster(resp~varb + fit:(block), pred, fam, varb, id, root, data=redata2015)
anova(aout2015a, aout2015)
summary(aout2015, show.graph = T)
#Designate fitness variable for 2016 data
fit <- grepl("totalseeds", as.character(redata2016$varb))
fit<- as.numeric(fit)
redata2016$fit<- fit
#check
with(redata2016, sort(unique(as.character(varb)[fit == 0])))
with(redata2016, sort(unique(as.character(varb)[fit == 1])))
#Fixed-effects aster model for 2016 data
aout2016a<- aster(resp~varb , pred, fam, varb, id, root, data=redata2016)
aout2016<- aster(resp~varb + fit:(block), pred, fam, varb, id, root, data=redata2016)
anova(aout2016a, aout2016)
summary(aout2016, show.graph = T)
#Designation of fitness variable for 2017 data
fit <- grepl("totalseeds", as.character(redata2017$varb))
fit<- as.numeric(fit)
redata2017$fit <- fit
#check
with(redata2017, sort(unique(as.character(varb)[fit == 0])))
with(redata2017, sort(unique(as.character(varb)[fit == 1])))
#add a variable "root" to redata files, where value is 1
redata2017<- data.frame(redata2017, root=1)
#make sure block, row, and position are factors
redata2017$block<- as.factor(redata2017$block)
redata2017$row<- as.factor(redata2017$row)
redata2017$position<- as.factor(redata2017$position)
#check
with(redata2017, sort(unique(as.character(varb)[fit == 0])))
with(redata2017, sort(unique(as.character(varb)[fit == 1])))
#Fixed-effects aster model for 2016 data
aout2017a<- aster(resp~varb, pred, fam, varb, id, root, data=redata2017)
aout2017<- aster(resp~varb + fit:(block), pred, fam, varb, id, root, data=redata2017)
anova(aout2017a, aout2017)
summary(aout2017, show.graph = T)
##############################################################
#Estimate mean fitness for 2015, 2016 (greenhouse cohort), and 2017 (greenhouse cohort) data
#generate MLE of saturated model mean value parameter vector: mu
pout2015<- predict.aster(aout2015, se.fit=TRUE)
pout2016<- predict.aster(aout2016, se.fit=TRUE)
pout2017<- predict.aster(aout2017, se.fit=TRUE)
#make up covariate data for hypothetical
#indivs that meet "typical" criteria:
#Therefore, "make up" covariate data for hypothetical individuals
#that re comparable and obtain mean values for them
##############
#make data.frame of indivudals for each block (1-8)
fred2015 <- data.frame(block=levels(redata2015$block),
Germ=1, flw=1, total.pods=1, total.pods.collected=1, totalseeds=1,root = 1)
fred2016 <- data.frame(block=levels(redata2016$block),
Germ=1, flw=1, total.pods=1, total.pods.collected=1, totalseeds=1,root = 1)
fred2017 <- data.frame(block=levels(redata2017$block),
Germ=1, flw=1, total.pods=1, total.pods.collected=1, totalseeds=1,root = 1)
#reshape the "made up data" just as the actual data
renewdata2015 <- reshape(fred2015, varying = list(vars),
direction = "long", timevar = "varb",
times = as.factor(vars), v.names = "resp")
renewdata2016 <- reshape(fred2016, varying = list(vars),
direction = "long", timevar = "varb",
times = as.factor(vars), v.names = "resp")
renewdata2017 <- reshape(fred2017, varying = list(vars),
direction = "long", timevar = "varb",
times = as.factor(vars), v.names = "resp")
#make character string from "varb" of renewdata,
#without actual values (e.g., the layers of varb in renewdata)
layer<- gsub("[0-9]", "", as.character(renewdata2015$varb))
layer<- gsub("[0-9]", "", as.character(renewdata2016$varb))
layer<- gsub("[0-9]", "", as.character(renewdata2017$varb))
#add layer to renewdata
renewdata2015<- data.frame(renewdata2015, layer= layer)
renewdata2016<- data.frame(renewdata2016, layer= layer)
renewdata2017<- data.frame(renewdata2017, layer= layer)
# add totalseeds in new layer col of renewdata as numeric, called fit
fit<- as.numeric(layer=="totalseeds")
#add fit to renewdata
renewdata2015<- data.frame(renewdata2015, fit = fit)
renewdata2016<- data.frame(renewdata2016, fit = fit)
renewdata2017<- data.frame(renewdata2017, fit = fit)
#Generate fintess estimates and standard errors for each block
nblock<- nrow(fred2015)#all data has same number of blocks so any file will do
nnode<- length(vars)
amat<- array(0, c(nblock, nnode, nblock))
dim(amat)# makes an 8 x 5 x 8 matrix
#only want means for k'th individual that contributes to expected
#fitness, and want to add only totalseeds entries
#makes 8 , 4x8 matrices that
foo<- grepl("totalseeds", vars)
for(k in 1:nblock)
amat[k, foo, k]<- 1
#generate predicted valuses using aout object, with renewdata, and amat format
pout.amat2015<- predict(aout2015, newdata= renewdata2015, varvar= varb,
idvar= id, root = root, se.fit=TRUE, amat = amat)
pout.amat2016<- predict(aout2016, newdata= renewdata2016, varvar= varb,
idvar= id, root = root, se.fit=TRUE, amat = amat)
pout.amat2017<- predict(aout2017, newdata= renewdata2017, varvar= varb,
idvar= id, root = root, se.fit=TRUE, amat = amat)
#combine std.err with estimates, and then round
#to three decimal places
gc2015<- cbind(pout.amat2015$fit, pout.amat2015$se.fit)
gc2016<- cbind(pout.amat2016$fit, pout.amat2016$se.fit)
gc2017<- cbind(pout.amat2017$fit, pout.amat2017$se.fit)
rownames(gc2015)<- as.character(fred2015$block)
rownames(gc2016)<- as.character(fred2016$block)
rownames(gc2017)<- as.character(fred2017$block)
colnames(gc2015)<- c("Expected Fitness", "SE")
colnames(gc2016)<- c("Expected Fitness", "SE")
colnames(gc2017)<- c("Expected Fitness", "SE")
#####################################################################
#The median expected fitness for each year is used to represent     #
#the site-specific fitness. The block effects representing these    #
# fitness values will be used to calcualte and convert  Va(W)       #
#estimates from the canonical to man-value parameter scale          #
#####################################################################
round(gc2015, 3) # median: block 6 - 1.112
round(gc2016, 3) # median: block 6 - 0.640
round(gc2017, 3)
setwd("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-adaptive-capacity/VaW_W_analyses/GC")
#Load reaster
#2015 reaster data
load(file="rout2015.RData")
#2016 reaster data
load(file="rout2016.RData")
#2017 reaster data
load(file="rout2017.RData")
library(aster)
#########################
#Estimate Va(W) for 2015#
#########################
#extract bhat - the estimates of random effects
bhat<- rout2015$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2015$obj, newcoef = rout2015$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[11]= block6),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2015$alpha
alpha[11] <- alpha[11] + b #block 6 effects
hoom <- predict(rout2015$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[1874, 5])#first individual in block 6, fifth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
GC_b2015<- bhat.sireGC.mu
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
gc2015den<-density(bhat.sireGC.mu)
GC2015_den<- cbind(gc2015den[[1]], gc2015den[[2]])
#write.csv(GC2015_den, "gc2015den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2015$obj, newcoef = rout2015$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
GC_Va<- 4*moom[1874 ,5]^2 * rout2015$nu[1]/map(0)
GC_Va #1.8576
#extract bhat - the estimates of random effects
bhat<- rout2016$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2016$obj, newcoef = rout2016$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[11]= block6),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2016$alpha
alpha[11] <- alpha[11] + b #block 6 effects
hoom <- predict(rout2016$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[2274, 5])#first individual in block 6, fifth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
GC_b2016<- bhat.sireGC.mu
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
gc2016den<- density(bhat.sireGC.mu)
GC2016_den<- cbind(gc2016den[[1]], gc2016den[[2]])
#write.csv(GC2016_den, "gc2016den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2016$obj, newcoef = rout2016$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
GC_Va<- 4*moom[2274 ,5]^2 * rout2016$nu[1]/map(0)
GC_Va #0.63142
#2016 reaster data
load(file="C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-adaptive-capacity/bootstrap/GC/2016rout2016.RData")
#2016 reaster data
load("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-adaptive-capacity/bootstrap/GC/2016rout2016.RData")
setwd("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-adaptive-capacity/bootstrap/GC")
#2016 reaster data
load("2016rout2016.RData")
#2016 reaster data
load("rout2016.RData")
setwd("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-adaptive-capacity/bootstrap/GC/2016")
#2016 reaster data
load("rout2016.RData")
#extract bhat - the estimates of random effects
bhat<- rout2016$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2016$obj, newcoef = rout2016$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[11]= block6),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2016$alpha
alpha[11] <- alpha[11] + b #block 6 effects
hoom <- predict(rout2016$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[2274, 5])#first individual in block 6, fifth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
GC_b2016<- bhat.sireGC.mu
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
gc2016den<- density(bhat.sireGC.mu)
GC2016_den<- cbind(gc2016den[[1]], gc2016den[[2]])
#write.csv(GC2016_den, "gc2016den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2016$obj, newcoef = rout2016$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
GC_Va<- 4*moom[2274 ,5]^2 * rout2016$nu[1]/map(0)
GC_Va #0.63142
