direction = "long", timevar = "varb",
times = as.factor(vars), v.names = "resp")
layer<- gsub("[0-9]", "", as.character(renewdata2$varb))
renewdata2<- data.frame(renewdata2, layer= layer)
fit<- as.numeric(layer=="totalseeds")
renewdata2<- data.frame(renewdata2, fit = fit)
#can make CI for these "typical" estimaes of fitness...not interesting
pout2<- predict(aout1, newdata= renewdata2, varvar= varb,
idvar = id, root = root, se.fit = TRUE)
#put the parameter estimates into a matrix with individuals in rows
#and nodes along columns
nnode<- length(vars)
sally<- matrix(pout2$fit, ncol = nnode)
dim(sally)#yes! 1 x 4 matrix: 1 indiv by 4 nodes
#name the rows (only one row) the popname (GC) and columns (as nodes)
rownames(sally)<- "CS"
colnames(sally)<- unique(as.character(renewdata$varb))
#using just seed set (normal seeds only for now), the file "herman"
#has the desired estimates of expected fitness for a "typical" individual
#in each block.  NOTE: still need to generate SE for these estimates
herman<- sally[,grepl("totalseeds", colnames(sally))]
herman
#try to get standard errors for predictions
nblock<- nrow(fred2)
nnode<- length(vars)
amat<- array(0, c(nblock, nnode, nblock))
dim(amat)# makes an 1 x 4 x 1 matrix
foo2<- grepl("totalseeds", vars)
for(k in 1:nblock)
amat[k, foo2, k]<- 1
pout.amat<- predict(aout1, newdata= renewdata2, varvar= varb,
idvar= id, root = root, se.fit=TRUE, amat = amat)
#pout.amat$fit should be the same as file "herman"
herman
pout.amat$fit #they are the same
#combine std.err with estimates, and then round
#to three decimal places
foo2<- cbind(pout.amat$fit, pout.amat$se.fit)
rownames(foo2)<- "CS"
colnames(foo2)<- c("estimates", "std.err.")
CS<- round(foo2, 3)
CS
#####################################################################################
#####################################################################################
###########################Deep Breath...Random Effects!#############################
#####################################################################################
#####################################################################################
#recall the "cleaned" data from above work
head(data.CS)
#make Germ (did germinate at all?) variable in origional data
data.CS$Germ=ifelse(data.CS$presence1|data.CS$presence2|data.CS$presence3|data.CS$presence4|data.CS$presence5|data.CS$presence6|data.CS$presence7 >0, 1, 0)
#make data.frame with positionID row position maternalID paternalID Germ Flw Seed.ct
data3<- data.CS[c("block","position", "row", "maternalID", "paternalID","Germ", "flw", "total.pods","total.pods.collected", "totalseeds")]
data3$cohort<- "greenhouse"
data3$year<- 2015
head(data3)
cs2015<- data3
#**********************************************************************
#Get data
data.CS <-read.csv("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-va-w-2015-and-2016/data/CS_2016_final.csv")
#troublesome formatting in two columns of "Notes"
data.CS$notes4<-NULL
data.CS$notes5<- NULL
#**********************************************************************************
#Convert NAs in data to 0
data.CS[is.na(data.CS)]<-0
#getting error message, that generates NAs due to non factor levels
#what rows have this issue?
which(is.na(data.CS), arr.ind=TRUE) #row: 924, col 32 and 39
#was something wrong with "notes4" and "notes5" factor levels.  Deleted them with
#code on lines 17 and 18
head(data.CS)
#**********************************************************************************
#Create Additional columnn with date (census #) of first flower
data.CS$flower.date=ifelse(data.CS$flower2==1,2,ifelse(data.CS$flower3==1,3,
ifelse(data.CS$flower4==1,4,ifelse(data.CS$flower5==1,5,0))))
#**********************************************************************************
#Find detection errors in data for presence columns
subset(data.CS,presence1==1&presence2==0&presence3==1) # several errors
subset(data.CS,presence2==1&presence3==0&presence4==1) # several errors
subset(data.CS,presence3==1&presence4==0&presence5==1) # no errors
#**********************************************************************************
#Fix detection errors in presence data
##In some cases plants were marked as present in one census, not present in the next census, and then present again in the following census.
###We want to clean these errors so that individuals are consistently present once germinated and before dying
data.CS$presence2[data.CS$presence1==1&data.CS$presence3==1]=1
data.CS$presence3[data.CS$presence2==1&data.CS$presence4==1]=1
data.CS$presence4[data.CS$presence3==1&data.CS$presence5==1]=1
#**********************************************************************************
#Verify that detection errors in data for presence columns are no longer present
subset(data.CS,presence1==1&presence2==0&presence3==1) # no errors
subset(data.CS,presence2==1&presence3==0&presence4==1) # no errors
subset(data.CS,presence3==1&presence4==0&presence5==1) # no errors
#*******************************************************************************
#Find detection errors in data for flowering columns
subset(data.CS,flower2==1&flower3==0&flower4==1) # 6 errors
subset(data.CS,flower3==1&flower4==0&flower5==1) # 2 errors
#*******************************************************************************
#Fix errors in flowering, once a plant has flowered it stays flowering until dead
data.CS$flower3[data.CS$flower2==1&data.CS$flower4==1]=1
data.CS$flower4[data.CS$flower3==1&data.CS$flower5==1]=1
#*******************************************************************************
#Verify that detection errors in data for flowering columns are no longer present
subset(data.CS,flower2==1&flower3==0&flower4==1) # 0 errors
subset(data.CS,flower3==1&flower4==0&flower5==1) # 0 errors
#********************************************************************************
#Find data points where there are seeds but not pods
subset(data.CS,total.pods.collected==0&seed.ct2>0) #0 issues
#Create Additional variable (called flw) if plant flowered at all (0= no, 1 = yes)
data.CS$flw=ifelse(data.CS$flower.date > 0, 1,0)
##Any plantings with p1=1 and p9= 1
ends<- subset(data.CS, presence1==1&presence5==1)
#plants with a zero between p1=1 and p9=1
zeros<- subset(ends, presence2==0|presence3==0|presence4==0)#2 plants have this condition
#fill in ones for all platns with p2=1 and p5=1
data.CS$presence2[data.CS$presence1==1&data.CS$presence5==1]= 1
data.CS$presence3[data.CS$presence2==1&data.CS$presence5==1]= 1
data.CS$presence4[data.CS$presence4==1&data.CS$presence5==1]= 1
#check for correction
ends<- subset(data.CS, presence1==1&presence5==1)
#plants with a zero between p1=1 and p7=1
zeros<- subset(ends, presence2==0|presence3==0|presence4==0)#no plants meet this criteria.  Correction complete.
#make new variable of total.pods
#data.CS$total.pods= data.CS$green.pods7 + data.CS$ground.pods7 + data.CS$crispy.pods7
#totalseeds
#data.CS$totalseeds = data.CS$seed.ct + data.CS$green.seed.ct + data.CS$ground.seed.ct
#make block variable
data.CS$block <- substr(data.CS$row,1,1)
data.CS$total.pods<- data.CS$pods.collected4 + data.CS$pods.collected5 + data.CS$pods.collected6 + data.CS$pods.on.plant.4 + data.CS$pods.on.plant5 + data.CS$green.pods.collected5 + data.CS$green.pods.on.plant4 + data.CS$total.pods.collected
#make variable if plant germinated at all (from p1 to p5)? 1= yes, 0= no
data.CS$Germ=ifelse(data.CS$presence1|data.CS$presence2|data.CS$presence3|data.CS$presence4|data.CS$presence5 >0, 1, 0)
#recall, already subsetted "greenhouse cohort" already
data3<- data.CS[c("block","position", "row", "maternalID","paternalID", "Germ", "flw","total.pods", "total.pods.collected", "seed.ct2", "cohort")]
#fruits but no flw?
subset(data3, flw==0&total.pods.collected>0)#no issues
#flw but no germ?
subset(data3, flw==1 & Germ==0)#0 plants
#change name of seed.ct2 to seeds...so problems with w estimates dont happen
colnames(data3)[11]<- "totalseeds"
data3$year<- 2016
names(cs2015)
names(data3)
#**********************************************************************
#Get data
data.CS <-read.csv("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-va-w-2015-and-2016/data/CS_2016_final.csv")
#troublesome formatting in two columns of "Notes"
data.CS$notes4<-NULL
data.CS$notes5<- NULL
#**********************************************************************************
#Convert NAs in data to 0
data.CS[is.na(data.CS)]<-0
#getting error message, that generates NAs due to non factor levels
#what rows have this issue?
which(is.na(data.CS), arr.ind=TRUE) #row: 924, col 32 and 39
#was something wrong with "notes4" and "notes5" factor levels.  Deleted them with
#code on lines 17 and 18
head(data.CS)
#**********************************************************************************
#Create Additional columnn with date (census #) of first flower
data.CS$flower.date=ifelse(data.CS$flower2==1,2,ifelse(data.CS$flower3==1,3,
ifelse(data.CS$flower4==1,4,ifelse(data.CS$flower5==1,5,0))))
#**********************************************************************************
#Find detection errors in data for presence columns
subset(data.CS,presence1==1&presence2==0&presence3==1) # several errors
subset(data.CS,presence2==1&presence3==0&presence4==1) # several errors
subset(data.CS,presence3==1&presence4==0&presence5==1) # no errors
#**********************************************************************************
#Fix detection errors in presence data
##In some cases plants were marked as present in one census, not present in the next census, and then present again in the following census.
###We want to clean these errors so that individuals are consistently present once germinated and before dying
data.CS$presence2[data.CS$presence1==1&data.CS$presence3==1]=1
data.CS$presence3[data.CS$presence2==1&data.CS$presence4==1]=1
data.CS$presence4[data.CS$presence3==1&data.CS$presence5==1]=1
#**********************************************************************************
#Verify that detection errors in data for presence columns are no longer present
subset(data.CS,presence1==1&presence2==0&presence3==1) # no errors
subset(data.CS,presence2==1&presence3==0&presence4==1) # no errors
subset(data.CS,presence3==1&presence4==0&presence5==1) # no errors
#*******************************************************************************
#Find detection errors in data for flowering columns
subset(data.CS,flower2==1&flower3==0&flower4==1) # 6 errors
subset(data.CS,flower3==1&flower4==0&flower5==1) # 2 errors
#*******************************************************************************
#Fix errors in flowering, once a plant has flowered it stays flowering until dead
data.CS$flower3[data.CS$flower2==1&data.CS$flower4==1]=1
data.CS$flower4[data.CS$flower3==1&data.CS$flower5==1]=1
#*******************************************************************************
#Verify that detection errors in data for flowering columns are no longer present
subset(data.CS,flower2==1&flower3==0&flower4==1) # 0 errors
subset(data.CS,flower3==1&flower4==0&flower5==1) # 0 errors
#********************************************************************************
#Find data points where there are seeds but not pods
subset(data.CS,total.pods.collected==0&seed.ct2>0) #0 issues
#Create Additional variable (called flw) if plant flowered at all (0= no, 1 = yes)
data.CS$flw=ifelse(data.CS$flower.date > 0, 1,0)
##Any plantings with p1=1 and p9= 1
ends<- subset(data.CS, presence1==1&presence5==1)
#plants with a zero between p1=1 and p9=1
zeros<- subset(ends, presence2==0|presence3==0|presence4==0)#2 plants have this condition
#fill in ones for all platns with p2=1 and p5=1
data.CS$presence2[data.CS$presence1==1&data.CS$presence5==1]= 1
data.CS$presence3[data.CS$presence2==1&data.CS$presence5==1]= 1
data.CS$presence4[data.CS$presence4==1&data.CS$presence5==1]= 1
#check for correction
ends<- subset(data.CS, presence1==1&presence5==1)
#plants with a zero between p1=1 and p7=1
zeros<- subset(ends, presence2==0|presence3==0|presence4==0)#no plants meet this criteria.  Correction complete.
#make new variable of total.pods
#data.CS$total.pods= data.CS$green.pods7 + data.CS$ground.pods7 + data.CS$crispy.pods7
#totalseeds
#data.CS$totalseeds = data.CS$seed.ct + data.CS$green.seed.ct + data.CS$ground.seed.ct
#make block variable
data.CS$block <- substr(data.CS$row,1,1)
data.CS$total.pods<- data.CS$pods.collected4 + data.CS$pods.collected5 + data.CS$pods.collected6 + data.CS$pods.on.plant.4 + data.CS$pods.on.plant5 + data.CS$green.pods.collected5 + data.CS$green.pods.on.plant4 + data.CS$total.pods.collected
#make variable if plant germinated at all (from p1 to p5)? 1= yes, 0= no
data.CS$Germ=ifelse(data.CS$presence1|data.CS$presence2|data.CS$presence3|data.CS$presence4|data.CS$presence5 >0, 1, 0)
#recall, already subsetted "greenhouse cohort" already
data3<- data.CS[c("block","position", "row", "maternalID","paternalID", "Germ", "flw","total.pods", "total.pods.collected", "seed.ct2", "cohort")]
#fruits but no flw?
subset(data3, flw==0&total.pods.collected>0)#no issues
#flw but no germ?
subset(data3, flw==1 & Germ==0)#0 plants
#change name of seed.ct2 to seeds...so problems with w estimates dont happen
colnames(data3)[10]<- "totalseeds"
data3$year<- 2016
names(cs2015)
names(data3)
head(dat3)
head(data3)
cs2016<- data3
cs<- read.csv("C:/Users/Mason Kulbaba/Dropbox/Rscripts/Chamaecrista/Census.Data.2017/CERA/CS2017.merged.csv")
#make germ
cs$Germ=ifelse(cs$Pres1| cs$Pres2| cs$Pres3| cs$Pres4 >0,1,0)
#make flw
cs$flw=ifelse(cs$FL.3|cs$FL.4 >0,1,0)
cs$totalseeds= cs$Total.Good.Seeds + cs$Total.Poor.Seeds
cs<- cs[c("Row", "position", "cohort", "damID", "sireID", "Germ", "flw", "total.pods", "Pods.Col4", "totalseeds")]
head9cs
head(cs)
names(cs2016)
names(cs)
cs<- read.csv("C:/Users/Mason Kulbaba/Dropbox/Rscripts/Chamaecrista/Census.Data.2017/CERA/CS2017.merged.csv")
head(cs)
cs<- read.csv("C:/Users/Mason Kulbaba/Dropbox/Rscripts/Chamaecrista/Census.Data.2017/CERA/CS2017.merged.csv")
#make germ
cs$Germ=ifelse(cs$Pres1| cs$Pres2| cs$Pres3| cs$Pres4 >0,1,0)
#make flw
cs$flw=ifelse(cs$FL.3|cs$FL.4 >0,1,0)
cs$totalseeds= cs$Total.Good.Seeds + cs$Total.Poor.Seeds
cs<- cs[c("Row", "position", "cohort", "damID", "sireID", "Germ", "flw", "total.pods", "Pods.Col4", "totalseeds")]
#checks
subset(cs, flw==1 & Germ==0) #no errors
subset(cs, total.pods >0 & flw==0) #no errors
subset(cs, total.pods >0 & Germ==0) #no errors
subset(cs, Pods.Col4 > total.pods)#no errors
subset(cs, totalseeds > 0 & Pods.Col4 ==0)#no errors
vars<- c("Germ", "flw", "total.pods", "Pods.Col4", "totalseeds")
cs$Row<- as.factor(cs$Row)
cs$position<- as.factor(cs$position)
cs$block <- substr(cs$Row,1,1)
head(cs)
names(cs2016)
cs<- cs[c("block", "position", "row", "damID", "sireID", "Germ", "flw", "total.pods", "Pods.col4", "totalseeds", "cohort")]
cs<- cs[c("block", "position", "Row", "damID", "sireID", "Germ", "flw", "total.pods", "Pods.col4", "totalseeds", "cohort")]
cs<- cs[c("block", "position", "Row", "damID", "sireID", "Germ", "flw", "total.pods", "Pods.Col4", "totalseeds", "cohort")]
cs$year<- 2017
colnames(cs)<- c("block", "position", "row", "maternalID", "paternalID", "Germ", "flw", "total.pods", "total.pods.collected", "totalseeds", "cohort", "year")
head(cs)
names(cs2015)
names(cs2016)
names(cs)
cs2017<-cs
names(cs2017)
csdat<- rbind(cs2015, cs2016, cs2017)
head(csdat)
tail(csdat)
write.csv(csdat, file="C:/Users/Mason Kulbaba/Dropbox/Rscripts/Final_VaW_Wbar/CS/csdat.csv", sep=",", quote=FALSE, rownames=FALSE)
write.csv(csdat, file="C:/Users/Mason Kulbaba/Dropbox/Rscripts/Final_VaW_Wbar/CS/csdat.csv", sep=",", quote=FALSE, row.names=FALSE)
two.loc.sims<-function(p,w.mat,r){
stopifnot(sum(p)==1)
p.array<-matrix(NA,nrow=n.gens,ncol=4)
d.array<-NA
p.array[1,]<-p
colnames(p.array)<-names(p)
for(gen in 2:n.gens){
w.marg<-apply(w.mat,1,function(whap){whap*p})
w.marg<-colSums(w.marg)
D<-p["AB"] - (p["AB"]+p["Ab"])*(p["AB"]+p["aB"])
d.array<-c(d.array,D)
D.vec<- c(-D,+D,+D,-D)
wbar<-sum(p*w.marg)
p.new<- (p*w.marg + r*D.vec*w.mat["AB","ab"])/wbar
p.array[gen,]<-p.new
p<-p.new
}
return(cbind(p.array,d.array))
}
stack.freqs.plot<-function(p.out,my.title=""){
stacked.freqs<-t(apply(p.out[,c("Ab","AB","ab","aB")],1,cumsum))
plot(stacked.freqs[,"Ab"],ylim=c(0,1),type="l",xlab="Generations",ylab="Frequencies",cex.lab=1.4,cex.axis=1.2,main=my.title,cex.main=1.4)
my.x<-1:n.gens
x.polygon<-c(my.x,rev(my.x))
polygon(x=x.polygon,c(stacked.freqs[,"Ab"],rep(0,n.gens)),col="blue")
polygon(x=x.polygon,c(stacked.freqs[,"AB"],rev(stacked.freqs[,"Ab"])),col="purple")
polygon(x=x.polygon,c(stacked.freqs[,"AB"],rev(stacked.freqs[,"aB"])),col="white")
polygon(x=x.polygon,c(stacked.freqs[,"aB"],rev(stacked.freqs[,"ab"])),col="red")
}
###Neutral Hitchhiking
n.gens<-500
p<-  c(0.001,0.099,0,0.9); names(p)<-c("AB","Ab","aB","ab")
w.add<-c(1,0.95,1,0.95);names(w.add)<-names(p)
w.mat<-outer(w.add,w.add,FUN="+")
layout(t(1:3))
par(mar=c(4,4,3,1))
p.out<-two.loc.sims(p,w.mat,r=0.0005); stack.freqs.plot(p.out,my.title="r=0.0005")
#plot(p.out[,"AB"]+p.out[,"Ab"],type="l",ylim=c(0,1))#lines(p.out[,"AB"]+p.out[,"aB"],col="red")
p.out<-two.loc.sims(p,w.mat,r=0.005); stack.freqs.plot(p.out,my.title="r=0.005")
p.out<-two.loc.sims(p,w.mat,r=0.05);stack.freqs.plot(p.out,my.title="r=0.05")
dev.copy2pdf(file="~/Dropbox/Courses/Popgen_teaching_Notes/figures/selection_recom_interaction/Neutral_Hitchhiking.pdf")
###Deleterious allele Hitchhiking
par(mar=c(4,4.1,3,1))
n.gens<-1000
p<-  c(0.001,0.099,0,0.9); names(p)<-c("AB","Ab","aB","ab")
w.add<-c(0.97,0.93,1,0.95);names(w.add)<-names(p)
w.mat<-outer(w.add,w.add,FUN="+")
layout(t(1:3))
p.out<-two.loc.sims(p,w.mat,r=0.00);stack.freqs.plot(p.out,my.title="r=0.0");
p.out<-two.loc.sims(p,w.mat,r=0.000005);stack.freqs.plot(p.out,my.title="r=0.000005");
p.out<-two.loc.sims(p,w.mat,r=0.0002);stack.freqs.plot(p.out,my.title="r=0.0005");
dev.copy2pdf(file="~/Dropbox/Courses/Popgen_teaching_Notes/figures/Deleterious_Hitchhiking.pdf")
##interference
layout(t(1:2))
n.gens<-1000
p<-  c(0.0,0.01,0.01,0.98); names(p)<-c("AB","Ab","aB","ab")
w.add<-c(1.14,1.08,1.06,1);names(w.add)<-names(p)
w.mat<-outer(w.add,w.add,FUN="+")
p.out<-two.loc.sims(p,w.mat,r=0.00)
stack.freqs.plot(p.out)
p<-  c(0.0,0.01,0.01,0.98); names(p)<-c("AB","Ab","aB","ab")
w.add<-c(1.1,1.06,1.055,1);names(w.add)<-names(p)
w.mat<-outer(w.add,w.add,FUN="+")
p.out<-two.loc.sims(p,w.mat,r=0.001)
stack.freqs.plot(p.out)
dev.copy2pdf(file="~/Dropbox/Courses/Popgen_teaching_Notes/figures/Interference.pdf")
###synergistic alleles & recom
n.gens<-200
layout(t(1:3))
#### This code was taken from the G x E analsyis, and repurposed to generate CIs
#### for the second Chamaecrista adaptive capacity paper
#########################################################################
### 1. PRELIMINARIES: set working directory, load packages & data
#########################################################################
setwd("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-adaptive-capacity/bootstrap/CS/2015")
# load packages
library(aster)
# load raster output
load("rout2015.RData")
# load redata file
load("redata2015.RData")
# load modmat.siredam matrix
load("modmat.siredam2015.RData")
modmat.siredamCS<- as.matrix(modmat.siredam2015)
#set seed
set.seed(1729)
#########################################################################
### 2. PREPARE FOR BOOTSTRAPPING
#########################################################################
### set up graphical model
pred<- c(0,1,2,3,4) #make sure this matches your model
# designate family for each node in graphical model
fam<- c(1,1,2,2,2) #make sure this matches your model
# generate "hat" estimates from data
alpha.hat <- rout2015$alpha
sigma.hat <- rout2015$sigma
nu.hat <- rout2015$nu
b.hat <- rout2015$b
c.hat <- rout2015$c
sout <- summary(rout2015)
se.alpha.hat <- sout$alpha[ , "Std. Error"]
se.sigma.hat <- sout$sigma[ , "Std. Error"]
se.nu.hat <- sout$nu[ , "Std. Error"]
fixed <- rout2015$fixed
random <- rout2015$random
modmat.tot <- cbind(fixed, Reduce(cbind, random))
nfix <- ncol(fixed)
nrand <- sapply(random, ncol)
a.hat <- rep(sigma.hat, times = nrand)
# set outer (nboot) and inner (ndoubleboot)
nboot <- 100
ndoubleboot <- 31
### prepare for boots function that performs a single bootstrap
alpha.star <- matrix(NaN, nboot, length(alpha.hat))
sigma.star <- matrix(NaN, nboot, length(sigma.hat))
nu.star <- matrix(NaN, nboot, length(nu.hat))
se.alpha.star <- alpha.star
se.sigma.star <- sigma.star
se.nu.star <- nu.star
# make boots function
boots <- function(alpha, sigma) {
a.hat <- rep(sigma, times = nrand)
c.star <- rnorm(sum(nrand))
b.star <- a.hat * c.star
eff.star <- c(alpha, b.star)
phi.star <- as.numeric(as.vector(rout2015$obj$origin) +
modmat.tot %*% eff.star)
theta.star <- astertransform(phi.star, rout2015$obj,
to.cond = "conditional", to.mean = "canonical")
y.star <- raster(theta.star, pred, fam, rout2015$obj$root)
y.star <- as.vector(y.star)
rout.star <- reaster(y.star ~ varb + fit : (block), # make sure this matches your model
list(parental=~0 + fit:modmat.siredam2015),
pred, fam, varb, id, root, data = redata2015,
effects = c(alpha, c.star), sigma = sigma)
}
# generate function to compute VaW estimate
VaW<- function (rout2015){
bhat<- rout2015$b
bhat.sire<- bhat[grep("sireID", names(bhat))]
hoom.star <- predict(rout2015$obj,  newcoef = rout2015$alpha)
hoom.star<- matrix(hoom.star, ncol =5)
hoom.star<- hoom.star[ , 5]
# mapping function
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2015$alpha
alpha[6] <- alpha[6] + b # adding fixed effect for fit:block1 (e.g. alpha[6]), make sure this matches your model
hoom.star <- predict(rout2015$obj, newcoef = alpha)
hoom.star<- matrix(hoom.star, ncol = 5)
return(hoom.star[1, 5]) # return value of 5th node (seed #) for 1st indiv (1st indiv in block 1). Change this to whatever your terminal fitness node is (e.g. fruit #)
}
fred<- Vectorize(map)
bhat.sire.mu<- fred(bhat.sire)
hoom.star2<- predict(rout2015$obj, newcoef = rout2015$alpha, se.fit=TRUE, info.tol = 1e-13)
goom.star <- hoom.star2$gradient
moom.star<- goom.star[,5]
moom.star<- matrix(moom.star, ncol=5)
# calcualtion for Va(w)
CS_Va<- 4*moom.star[1 , 5]^2 * rout2015$nu[1]/map(0) # final calcuation of additive genetic variance for fitness
}
#########################################################################
### 3. DOUBLE BOOTSTRAPPING
#########################################################################
CS_Va.star <- rep(-1, nboot)
CS_Va.star.star<- rep(-1, ndoubleboot)
se.CS_Va.star <- rep(-1, nboot)
se.CS_Va.star_sd <- rep(-1, nboot)
for (iboot in 1:nboot) {
tryCatch({
rout.star <- boots(alpha.hat, sigma.hat)
if("try-error" %in% class(rout.star)) stop("reaster error (Nelder-Mead with pickle fail?)")
},error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
alpha.star.star <- matrix(NaN, ndoubleboot, length(alpha.hat))
sigma.star.star <- matrix(NaN, ndoubleboot, length(sigma.hat))
nu.star.star <- matrix(NaN, ndoubleboot, length(nu.hat))
tryCatch({
CS_Va.star[iboot]<- VaW(rout.star) # function for VaW calcualtion at bootstrap level 1
if("try-error" %in% class( CS_Va.star[iboot])) stop("reaster error (Nelder-Mead with pickle fail?)")
},error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
print(CS_Va.star[iboot]) # will print outer bootstrap estimate for each nboot interation
print(iboot)
for (idoubleboot in 1:ndoubleboot) {
tryCatch({
rout.star.star <- boots(rout.star$alpha, rout.star$sigma)
if("try-error" %in% class(rout.star.star)) stop("reaster error (Nelder-Mead with pickle fail?)")
},error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
tryCatch({
CS_Va.star.star[idoubleboot]<- VaW(rout.star.star) # same function for VaW calcualtion at bootstrap level 2
if("try-error" %in% class( CS_Va.star.star[idoubleboot])) stop("aster.predict error (direction of recession error?)")
},error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
alpha.star.star[idoubleboot, ] <- rout.star.star$alpha
sigma.star.star[idoubleboot, ] <- rout.star.star$sigma
nu.star.star[idoubleboot, ] <- rout.star.star$nu
print(CS_Va.star.star[idoubleboot]) # will print each inner bootstrap estimate for each ndboubleboot iteration
print(idoubleboot)
}
# This code uses the interquartile range as our measure of scale, when we set the inner bootstrap
# to 31 (difference between the 25'th and 8'th elements).  We used IQR during the testing of this code
# as it is a more robust measure of scale with small samples sizes (we developed this code with ndoubleboot = 7).
# However, at larger sample sizes standard deviation is suitable. Therefore, the current code generates
# both IQR and standard deviation scale metrics
se.CS_Va.star[iboot] <- diff(sort(CS_Va.star.star)[c(8,25)]) # calculate IQR
se.CS_Va.star_sd[iboot]<- sd(CS_Va.star.star) # calcualte standard deviation
}
#########################################################################
### 4. GENERATE BOOTSTRAP t CONFIDENCE INTERVALS
#########################################################################
# Save Rdata for entire bootstrap run
save.image("doubleboot_CS2015_run.RData")
#load("doubleboot_CS2015_run.RData")
# Generate Va(W) from data
CS_Va.hat <- VaW(rout2015) # generates Va(W) from data
# calculate t for IQR-based confidence interval
t <- (CS_Va.star - CS_Va.hat) / se.CS_Va.star
# set confidence level
conf.level <- 0.95
# generate critical values with t for IQR-based confidence interval
crit <- quantile(t, probs = c((1 - conf.level) / 2, (1 + conf.level) / 2))  # note this uses the t just calculated
# generate IQR and standard deviation measures of scale
foo <- CS_Va.star[1:nboot]    # the outer loop Va's
se.CS_Va.hat <- diff(sort(foo)[c(25,76)])  # middle 50 percent of 100 or so
se.CS_Va.hat_sd <- sd(foo)  # standard deviation calculation of scale
# Conf. Int. for CS_Va with IQR scale metric
CS_Va.hat - rev(crit) * se.CS_Va.hat
# calculate t for standard deviation-based confidence interval
t <- (CS_Va.star - CS_Va.hat) / se.CS_Va.star_sd
# generate critical values with t for standard deviation-based confidence interval
crit <- quantile(t, probs = c((1 - conf.level) / 2, (1 + conf.level) / 2))
# Conf. Int. for CS_Va with standard deviation scale metric
CS_Va.hat - rev(crit) * se.CS_Va.hat_sd
CS_Va.star
CS_Va.star.star
