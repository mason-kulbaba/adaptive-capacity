subset(data.CS,presence3==1&presence4==0&presence5==1) # no errors
subset(data.CS,presence4==1&presence5==0&presence6==1) # no errors
subset(data.CS,presence5==1&presence6==0&presence7==1) # no errors
#*******************************************************************************
#Find detection errors in data for flowering columns
subset(data.CS,flowering4==1&flowering5==0&flowering6==1) # no errors
subset(data.CS,flowering5==1&flowering6==0&flowering7==1) # 4 errors
subset(data.CS,presence7==1&flowering7==0&flowering6==1) # no errors
#*******************************************************************************
#Fix errors in flowering, once a plant has flowered it stays flowering until dead
data.CS$flowering5[data.CS$flowering4==1&data.CS$flowering6==1]=1
data.CS$flowering6[data.CS$flowering5==1&data.CS$flowering7==1]=1
data.CS$flowering7[data.CS$presence7==1&data.CS$flowering6==1]=1
#*******************************************************************************
#Verify that detection errors in data for flowering columns are no longer present
subset(data.CS,flowering4==1&flowering5==0&flowering6==1) # no errors
subset(data.CS,flowering5==1&flowering6==0&flowering7==1) # no errors
subset(data.CS,presence7==1&flowering7==0&flowering6==1) # no errors
#********************************************************************************
#Find data points where there is a pod count, but no seed count
subset(data.CS,crispy.pods7>=1&seed.ct==0) #6 missing
#Create Additional variable (called flw) if plant flowered at all (0= no, 1 = yes)
data.CS$flw=ifelse(data.CS$flower.date > 0, 1,0)
##Any plantings with p1=1 and p9= 1
ends<- subset(data.CS, presence1==1&presence7==1)
#plants with a zero between p1=1 and p9=1
zeros<- subset(ends, presence2==0|presence3==0|presence4==0|presence5==0|presence6==0|presence7==0)#10 plants have this condition
#fill in ones for all platns with p1=1 and p9=1
data.CS$presence2[data.CS$presence1==1&data.CS$presence7==1]= 1
data.CS$presence3[data.CS$presence1==1&data.CS$presence7==1]= 1
data.CS$presence4[data.CS$presence1==1&data.CS$presence7==1]= 1
data.CS$presence5[data.CS$presence1==1&data.CS$presence7==1]= 1
data.CS$presence6[data.CS$presence1==1&data.CS$presence7==1]= 1
data.CS$presence7[data.CS$presence1==1&data.CS$presence7==1]= 1
#check for correction
ends<- subset(data.CS, presence1==1&presence7==1)
#plants with a zero between p1=1 and p7=1
zeros<- subset(ends, presence2==0|presence3==0|presence4==0|presence5==0|presence6==0|presence7==0)#no plants meet this criteria.  Correction complete.
#make new variable of total.pods
data.CS$total.pods= data.CS$green.pods7 + data.CS$ground.pods7 + data.CS$crispy.pods7
#totalseeds
data.CS$totalseeds = data.CS$seed.ct + data.CS$green.seed.ct + data.CS$ground.seed.ct
#make block variable
data.CS$block <- substr(data.CS$row,1,1)
data.CS$block <- substr(data.CS$row,1,1)
#make variable if plant germinated at all (from p1 to p9)? 1= yes, 0= no
data.CS$Germ=ifelse(data.CS$presence1|data.CS$presence2|data.CS$presence3|data.CS$presence4|data.CS$presence5|data.CS$presence6|data.CS$presence7 >0, 1, 0)
data.CS$total.pods.collected<- data.CS$crispy.pods7 + data.CS$green.pods7 + data.CS$ground.pods7
data3<- data.CS[c("position", "block", "row", "Germ", "flw", "total.pods", "total.pods.collected", "totalseeds")]
###########
test1<- subset(data3,total.pods ==0 & totalseeds >0) #no erros
#load aster package
library(aster)
#####################################################
##################Aster Modeling#####################
#####################################################
#make response data a vector
vars<- c("Germ","flw","total.pods", "total.pods.collected", "totalseeds")
#to estimate mean fitness, we need to identify (via a new variable) which node(?) will be used
#to calcualte fitness.  In this case, we want to identiy seed.ct as that variable.
#reshape data so that all response variables are located in a single vector in a new data
#set called "redata
redata <- reshape(data3, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
#####Fitness code from Ruth####
#Designation of fitness variable
fit <- grepl("totalseeds", as.character(redata$varb))
fit<- as.numeric(fit)
redata$fit <- fit
with(redata, sort(unique(as.character(varb)[fit == 0])))
with(redata, sort(unique(as.character(varb)[fit == 1])))
#add a variable "root" to redata, where value is 1
redata<- data.frame(redata, root=1)
pred<- c(0,1,2,3,4)
fam<- c(1,1,2,2,2)
sapply(fam.default(), as.character)[fam]
#basic first model with "block"
aout<- aster(resp~varb + fit:(block), pred, fam, varb, id, root, data=redata)
summary(aout)
#compare two models
#anova(aout1, aout2)#nothing gained from position again
fred <- data.frame(block=levels(as.factor(redata$block)),
Germ=1, flw=1, total.pods=1,total.pods.collected=1,totalseeds=1,root = 1)
renewdata <- reshape(fred, varying = list(vars),
direction = "long", timevar = "varb",
times = as.factor(vars), v.names = "resp")
layer<- gsub("[0-9]", "", as.character(renewdata$varb))
renewdata<- data.frame(renewdata, layer= layer)
fit<- as.numeric(layer=="totalseeds")
renewdata<- data.frame(renewdata, fit = fit)
#can make CI for these "typical" estimaes of fitness...not interesting
pout<- predict(aout, newdata= renewdata, varvar= varb,
idvar = id, root = root, se.fit = TRUE)
#put the parameter estimates into a matrix with individuals in rows
#and nodes along columns
nnode<- length(vars)
sally<- matrix(pout$fit, ncol = nnode)
dim(sally)#yes! 4 x 4 matrix: 4 indiv by 4 nodes
#name the rows (by block id) and columns (as nodes)
rownames(sally)<- unique(as.character(renewdata$block))
colnames(sally)<- unique(as.character(renewdata$varb))
#using just seed set (normal seeds only for now), the file "herman"
#has the desired estimates of expected fitness for a "typical" individual
#in each block.  NOTE: still need to generate SE for these estimates
herman<- sally[,grepl("totalseeds", colnames(sally))]
herman
#try to get standard errors for predictions
nblock<- nrow(fred)
nnode<- length(vars)
amat<- array(0, c(nblock, nnode, nblock))
dim(amat)# makes an 4 x 4 x 4 matrix
foo<- grepl("totalseeds", vars)
for(k in 1:nblock)
amat[k, foo, k]<- 1
pout.amat<- predict(aout, newdata= renewdata, varvar= varb,
idvar= id, root = root, se.fit=TRUE, amat = amat)
#pout.amat$fit should be the same as file "herman"
herman
pout.amat$fit #they are the same
#combine std.err with estimates, and then round
#to three decimal places
foo<- cbind(pout.amat$fit, pout.amat$se.fit)
rownames(foo)<- as.character(fred$block)
colnames(foo)<- c("estimates", "std.err.")
round(foo, 3)#use block 2 as median value~ for a "typical" individual
write.table(foo, file="C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-va-w-2015-and-2016/results/CS_2015estimates.txt", quote=FALSE, row.names = FALSE)
##############################################
###now calculate estimate for GC population###
##############################################
fred2 <- data.frame(block=as.factor(2), Germ=1, flw=1, total.pods=1,totalseeds=1,root = 1)
renewdata2 <- reshape(fred2, varying = list(vars),
direction = "long", timevar = "varb",
times = as.factor(vars), v.names = "resp")
layer<- gsub("[0-9]", "", as.character(renewdata2$varb))
renewdata2<- data.frame(renewdata2, layer= layer)
fit<- as.numeric(layer=="totalseeds")
renewdata2<- data.frame(renewdata2, fit = fit)
#can make CI for these "typical" estimaes of fitness...not interesting
pout2<- predict(aout1, newdata= renewdata2, varvar= varb,
idvar = id, root = root, se.fit = TRUE)
#put the parameter estimates into a matrix with individuals in rows
#and nodes along columns
nnode<- length(vars)
sally<- matrix(pout2$fit, ncol = nnode)
dim(sally)#yes! 1 x 4 matrix: 1 indiv by 4 nodes
#name the rows (only one row) the popname (GC) and columns (as nodes)
rownames(sally)<- "CS"
colnames(sally)<- unique(as.character(renewdata$varb))
#using just seed set (normal seeds only for now), the file "herman"
#has the desired estimates of expected fitness for a "typical" individual
#in each block.  NOTE: still need to generate SE for these estimates
herman<- sally[,grepl("totalseeds", colnames(sally))]
herman
#try to get standard errors for predictions
nblock<- nrow(fred2)
nnode<- length(vars)
amat<- array(0, c(nblock, nnode, nblock))
dim(amat)# makes an 1 x 4 x 1 matrix
foo2<- grepl("totalseeds", vars)
for(k in 1:nblock)
amat[k, foo2, k]<- 1
pout.amat<- predict(aout1, newdata= renewdata2, varvar= varb,
idvar= id, root = root, se.fit=TRUE, amat = amat)
#pout.amat$fit should be the same as file "herman"
herman
pout.amat$fit #they are the same
#combine std.err with estimates, and then round
#to three decimal places
foo2<- cbind(pout.amat$fit, pout.amat$se.fit)
rownames(foo2)<- "CS"
colnames(foo2)<- c("estimates", "std.err.")
CS<- round(foo2, 3)
CS
#####################################################################################
#####################################################################################
###########################Deep Breath...Random Effects!#############################
#####################################################################################
#####################################################################################
#recall the "cleaned" data from above work
head(data.CS)
#make Germ (did germinate at all?) variable in origional data
data.CS$Germ=ifelse(data.CS$presence1|data.CS$presence2|data.CS$presence3|data.CS$presence4|data.CS$presence5|data.CS$presence6|data.CS$presence7 >0, 1, 0)
#make data.frame with positionID row position maternalID paternalID Germ Flw Seed.ct
data3<- data.CS[c("block","position", "row", "maternalID", "paternalID","Germ", "flw", "total.pods","total.pods.collected", "totalseeds")]
data3$cohort<- "greenhouse"
data3$year<- 2015
head(data3)
cs2015<- data3
#**********************************************************************
#Get data
data.CS <-read.csv("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-va-w-2015-and-2016/data/CS_2016_final.csv")
#troublesome formatting in two columns of "Notes"
data.CS$notes4<-NULL
data.CS$notes5<- NULL
#**********************************************************************************
#Convert NAs in data to 0
data.CS[is.na(data.CS)]<-0
#getting error message, that generates NAs due to non factor levels
#what rows have this issue?
which(is.na(data.CS), arr.ind=TRUE) #row: 924, col 32 and 39
#was something wrong with "notes4" and "notes5" factor levels.  Deleted them with
#code on lines 17 and 18
head(data.CS)
#**********************************************************************************
#Create Additional columnn with date (census #) of first flower
data.CS$flower.date=ifelse(data.CS$flower2==1,2,ifelse(data.CS$flower3==1,3,
ifelse(data.CS$flower4==1,4,ifelse(data.CS$flower5==1,5,0))))
#**********************************************************************************
#Find detection errors in data for presence columns
subset(data.CS,presence1==1&presence2==0&presence3==1) # several errors
subset(data.CS,presence2==1&presence3==0&presence4==1) # several errors
subset(data.CS,presence3==1&presence4==0&presence5==1) # no errors
#**********************************************************************************
#Fix detection errors in presence data
##In some cases plants were marked as present in one census, not present in the next census, and then present again in the following census.
###We want to clean these errors so that individuals are consistently present once germinated and before dying
data.CS$presence2[data.CS$presence1==1&data.CS$presence3==1]=1
data.CS$presence3[data.CS$presence2==1&data.CS$presence4==1]=1
data.CS$presence4[data.CS$presence3==1&data.CS$presence5==1]=1
#**********************************************************************************
#Verify that detection errors in data for presence columns are no longer present
subset(data.CS,presence1==1&presence2==0&presence3==1) # no errors
subset(data.CS,presence2==1&presence3==0&presence4==1) # no errors
subset(data.CS,presence3==1&presence4==0&presence5==1) # no errors
#*******************************************************************************
#Find detection errors in data for flowering columns
subset(data.CS,flower2==1&flower3==0&flower4==1) # 6 errors
subset(data.CS,flower3==1&flower4==0&flower5==1) # 2 errors
#*******************************************************************************
#Fix errors in flowering, once a plant has flowered it stays flowering until dead
data.CS$flower3[data.CS$flower2==1&data.CS$flower4==1]=1
data.CS$flower4[data.CS$flower3==1&data.CS$flower5==1]=1
#*******************************************************************************
#Verify that detection errors in data for flowering columns are no longer present
subset(data.CS,flower2==1&flower3==0&flower4==1) # 0 errors
subset(data.CS,flower3==1&flower4==0&flower5==1) # 0 errors
#********************************************************************************
#Find data points where there are seeds but not pods
subset(data.CS,total.pods.collected==0&seed.ct2>0) #0 issues
#Create Additional variable (called flw) if plant flowered at all (0= no, 1 = yes)
data.CS$flw=ifelse(data.CS$flower.date > 0, 1,0)
##Any plantings with p1=1 and p9= 1
ends<- subset(data.CS, presence1==1&presence5==1)
#plants with a zero between p1=1 and p9=1
zeros<- subset(ends, presence2==0|presence3==0|presence4==0)#2 plants have this condition
#fill in ones for all platns with p2=1 and p5=1
data.CS$presence2[data.CS$presence1==1&data.CS$presence5==1]= 1
data.CS$presence3[data.CS$presence2==1&data.CS$presence5==1]= 1
data.CS$presence4[data.CS$presence4==1&data.CS$presence5==1]= 1
#check for correction
ends<- subset(data.CS, presence1==1&presence5==1)
#plants with a zero between p1=1 and p7=1
zeros<- subset(ends, presence2==0|presence3==0|presence4==0)#no plants meet this criteria.  Correction complete.
#make new variable of total.pods
#data.CS$total.pods= data.CS$green.pods7 + data.CS$ground.pods7 + data.CS$crispy.pods7
#totalseeds
#data.CS$totalseeds = data.CS$seed.ct + data.CS$green.seed.ct + data.CS$ground.seed.ct
#make block variable
data.CS$block <- substr(data.CS$row,1,1)
data.CS$total.pods<- data.CS$pods.collected4 + data.CS$pods.collected5 + data.CS$pods.collected6 + data.CS$pods.on.plant.4 + data.CS$pods.on.plant5 + data.CS$green.pods.collected5 + data.CS$green.pods.on.plant4 + data.CS$total.pods.collected
#make variable if plant germinated at all (from p1 to p5)? 1= yes, 0= no
data.CS$Germ=ifelse(data.CS$presence1|data.CS$presence2|data.CS$presence3|data.CS$presence4|data.CS$presence5 >0, 1, 0)
#recall, already subsetted "greenhouse cohort" already
data3<- data.CS[c("block","position", "row", "maternalID","paternalID", "Germ", "flw","total.pods", "total.pods.collected", "seed.ct2", "cohort")]
#fruits but no flw?
subset(data3, flw==0&total.pods.collected>0)#no issues
#flw but no germ?
subset(data3, flw==1 & Germ==0)#0 plants
#change name of seed.ct2 to seeds...so problems with w estimates dont happen
colnames(data3)[11]<- "totalseeds"
data3$year<- 2016
names(cs2015)
names(data3)
#**********************************************************************
#Get data
data.CS <-read.csv("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-va-w-2015-and-2016/data/CS_2016_final.csv")
#troublesome formatting in two columns of "Notes"
data.CS$notes4<-NULL
data.CS$notes5<- NULL
#**********************************************************************************
#Convert NAs in data to 0
data.CS[is.na(data.CS)]<-0
#getting error message, that generates NAs due to non factor levels
#what rows have this issue?
which(is.na(data.CS), arr.ind=TRUE) #row: 924, col 32 and 39
#was something wrong with "notes4" and "notes5" factor levels.  Deleted them with
#code on lines 17 and 18
head(data.CS)
#**********************************************************************************
#Create Additional columnn with date (census #) of first flower
data.CS$flower.date=ifelse(data.CS$flower2==1,2,ifelse(data.CS$flower3==1,3,
ifelse(data.CS$flower4==1,4,ifelse(data.CS$flower5==1,5,0))))
#**********************************************************************************
#Find detection errors in data for presence columns
subset(data.CS,presence1==1&presence2==0&presence3==1) # several errors
subset(data.CS,presence2==1&presence3==0&presence4==1) # several errors
subset(data.CS,presence3==1&presence4==0&presence5==1) # no errors
#**********************************************************************************
#Fix detection errors in presence data
##In some cases plants were marked as present in one census, not present in the next census, and then present again in the following census.
###We want to clean these errors so that individuals are consistently present once germinated and before dying
data.CS$presence2[data.CS$presence1==1&data.CS$presence3==1]=1
data.CS$presence3[data.CS$presence2==1&data.CS$presence4==1]=1
data.CS$presence4[data.CS$presence3==1&data.CS$presence5==1]=1
#**********************************************************************************
#Verify that detection errors in data for presence columns are no longer present
subset(data.CS,presence1==1&presence2==0&presence3==1) # no errors
subset(data.CS,presence2==1&presence3==0&presence4==1) # no errors
subset(data.CS,presence3==1&presence4==0&presence5==1) # no errors
#*******************************************************************************
#Find detection errors in data for flowering columns
subset(data.CS,flower2==1&flower3==0&flower4==1) # 6 errors
subset(data.CS,flower3==1&flower4==0&flower5==1) # 2 errors
#*******************************************************************************
#Fix errors in flowering, once a plant has flowered it stays flowering until dead
data.CS$flower3[data.CS$flower2==1&data.CS$flower4==1]=1
data.CS$flower4[data.CS$flower3==1&data.CS$flower5==1]=1
#*******************************************************************************
#Verify that detection errors in data for flowering columns are no longer present
subset(data.CS,flower2==1&flower3==0&flower4==1) # 0 errors
subset(data.CS,flower3==1&flower4==0&flower5==1) # 0 errors
#********************************************************************************
#Find data points where there are seeds but not pods
subset(data.CS,total.pods.collected==0&seed.ct2>0) #0 issues
#Create Additional variable (called flw) if plant flowered at all (0= no, 1 = yes)
data.CS$flw=ifelse(data.CS$flower.date > 0, 1,0)
##Any plantings with p1=1 and p9= 1
ends<- subset(data.CS, presence1==1&presence5==1)
#plants with a zero between p1=1 and p9=1
zeros<- subset(ends, presence2==0|presence3==0|presence4==0)#2 plants have this condition
#fill in ones for all platns with p2=1 and p5=1
data.CS$presence2[data.CS$presence1==1&data.CS$presence5==1]= 1
data.CS$presence3[data.CS$presence2==1&data.CS$presence5==1]= 1
data.CS$presence4[data.CS$presence4==1&data.CS$presence5==1]= 1
#check for correction
ends<- subset(data.CS, presence1==1&presence5==1)
#plants with a zero between p1=1 and p7=1
zeros<- subset(ends, presence2==0|presence3==0|presence4==0)#no plants meet this criteria.  Correction complete.
#make new variable of total.pods
#data.CS$total.pods= data.CS$green.pods7 + data.CS$ground.pods7 + data.CS$crispy.pods7
#totalseeds
#data.CS$totalseeds = data.CS$seed.ct + data.CS$green.seed.ct + data.CS$ground.seed.ct
#make block variable
data.CS$block <- substr(data.CS$row,1,1)
data.CS$total.pods<- data.CS$pods.collected4 + data.CS$pods.collected5 + data.CS$pods.collected6 + data.CS$pods.on.plant.4 + data.CS$pods.on.plant5 + data.CS$green.pods.collected5 + data.CS$green.pods.on.plant4 + data.CS$total.pods.collected
#make variable if plant germinated at all (from p1 to p5)? 1= yes, 0= no
data.CS$Germ=ifelse(data.CS$presence1|data.CS$presence2|data.CS$presence3|data.CS$presence4|data.CS$presence5 >0, 1, 0)
#recall, already subsetted "greenhouse cohort" already
data3<- data.CS[c("block","position", "row", "maternalID","paternalID", "Germ", "flw","total.pods", "total.pods.collected", "seed.ct2", "cohort")]
#fruits but no flw?
subset(data3, flw==0&total.pods.collected>0)#no issues
#flw but no germ?
subset(data3, flw==1 & Germ==0)#0 plants
#change name of seed.ct2 to seeds...so problems with w estimates dont happen
colnames(data3)[10]<- "totalseeds"
data3$year<- 2016
names(cs2015)
names(data3)
head(dat3)
head(data3)
cs2016<- data3
cs<- read.csv("C:/Users/Mason Kulbaba/Dropbox/Rscripts/Chamaecrista/Census.Data.2017/CERA/CS2017.merged.csv")
#make germ
cs$Germ=ifelse(cs$Pres1| cs$Pres2| cs$Pres3| cs$Pres4 >0,1,0)
#make flw
cs$flw=ifelse(cs$FL.3|cs$FL.4 >0,1,0)
cs$totalseeds= cs$Total.Good.Seeds + cs$Total.Poor.Seeds
cs<- cs[c("Row", "position", "cohort", "damID", "sireID", "Germ", "flw", "total.pods", "Pods.Col4", "totalseeds")]
head9cs
head(cs)
names(cs2016)
names(cs)
cs<- read.csv("C:/Users/Mason Kulbaba/Dropbox/Rscripts/Chamaecrista/Census.Data.2017/CERA/CS2017.merged.csv")
head(cs)
cs<- read.csv("C:/Users/Mason Kulbaba/Dropbox/Rscripts/Chamaecrista/Census.Data.2017/CERA/CS2017.merged.csv")
#make germ
cs$Germ=ifelse(cs$Pres1| cs$Pres2| cs$Pres3| cs$Pres4 >0,1,0)
#make flw
cs$flw=ifelse(cs$FL.3|cs$FL.4 >0,1,0)
cs$totalseeds= cs$Total.Good.Seeds + cs$Total.Poor.Seeds
cs<- cs[c("Row", "position", "cohort", "damID", "sireID", "Germ", "flw", "total.pods", "Pods.Col4", "totalseeds")]
#checks
subset(cs, flw==1 & Germ==0) #no errors
subset(cs, total.pods >0 & flw==0) #no errors
subset(cs, total.pods >0 & Germ==0) #no errors
subset(cs, Pods.Col4 > total.pods)#no errors
subset(cs, totalseeds > 0 & Pods.Col4 ==0)#no errors
vars<- c("Germ", "flw", "total.pods", "Pods.Col4", "totalseeds")
cs$Row<- as.factor(cs$Row)
cs$position<- as.factor(cs$position)
cs$block <- substr(cs$Row,1,1)
head(cs)
names(cs2016)
cs<- cs[c("block", "position", "row", "damID", "sireID", "Germ", "flw", "total.pods", "Pods.col4", "totalseeds", "cohort")]
cs<- cs[c("block", "position", "Row", "damID", "sireID", "Germ", "flw", "total.pods", "Pods.col4", "totalseeds", "cohort")]
cs<- cs[c("block", "position", "Row", "damID", "sireID", "Germ", "flw", "total.pods", "Pods.Col4", "totalseeds", "cohort")]
cs$year<- 2017
colnames(cs)<- c("block", "position", "row", "maternalID", "paternalID", "Germ", "flw", "total.pods", "total.pods.collected", "totalseeds", "cohort", "year")
head(cs)
names(cs2015)
names(cs2016)
names(cs)
cs2017<-cs
names(cs2017)
csdat<- rbind(cs2015, cs2016, cs2017)
head(csdat)
tail(csdat)
write.csv(csdat, file="C:/Users/Mason Kulbaba/Dropbox/Rscripts/Final_VaW_Wbar/CS/csdat.csv", sep=",", quote=FALSE, rownames=FALSE)
write.csv(csdat, file="C:/Users/Mason Kulbaba/Dropbox/Rscripts/Final_VaW_Wbar/CS/csdat.csv", sep=",", quote=FALSE, row.names=FALSE)
two.loc.sims<-function(p,w.mat,r){
stopifnot(sum(p)==1)
p.array<-matrix(NA,nrow=n.gens,ncol=4)
d.array<-NA
p.array[1,]<-p
colnames(p.array)<-names(p)
for(gen in 2:n.gens){
w.marg<-apply(w.mat,1,function(whap){whap*p})
w.marg<-colSums(w.marg)
D<-p["AB"] - (p["AB"]+p["Ab"])*(p["AB"]+p["aB"])
d.array<-c(d.array,D)
D.vec<- c(-D,+D,+D,-D)
wbar<-sum(p*w.marg)
p.new<- (p*w.marg + r*D.vec*w.mat["AB","ab"])/wbar
p.array[gen,]<-p.new
p<-p.new
}
return(cbind(p.array,d.array))
}
stack.freqs.plot<-function(p.out,my.title=""){
stacked.freqs<-t(apply(p.out[,c("Ab","AB","ab","aB")],1,cumsum))
plot(stacked.freqs[,"Ab"],ylim=c(0,1),type="l",xlab="Generations",ylab="Frequencies",cex.lab=1.4,cex.axis=1.2,main=my.title,cex.main=1.4)
my.x<-1:n.gens
x.polygon<-c(my.x,rev(my.x))
polygon(x=x.polygon,c(stacked.freqs[,"Ab"],rep(0,n.gens)),col="blue")
polygon(x=x.polygon,c(stacked.freqs[,"AB"],rev(stacked.freqs[,"Ab"])),col="purple")
polygon(x=x.polygon,c(stacked.freqs[,"AB"],rev(stacked.freqs[,"aB"])),col="white")
polygon(x=x.polygon,c(stacked.freqs[,"aB"],rev(stacked.freqs[,"ab"])),col="red")
}
###Neutral Hitchhiking
n.gens<-500
p<-  c(0.001,0.099,0,0.9); names(p)<-c("AB","Ab","aB","ab")
w.add<-c(1,0.95,1,0.95);names(w.add)<-names(p)
w.mat<-outer(w.add,w.add,FUN="+")
layout(t(1:3))
par(mar=c(4,4,3,1))
p.out<-two.loc.sims(p,w.mat,r=0.0005); stack.freqs.plot(p.out,my.title="r=0.0005")
#plot(p.out[,"AB"]+p.out[,"Ab"],type="l",ylim=c(0,1))#lines(p.out[,"AB"]+p.out[,"aB"],col="red")
p.out<-two.loc.sims(p,w.mat,r=0.005); stack.freqs.plot(p.out,my.title="r=0.005")
p.out<-two.loc.sims(p,w.mat,r=0.05);stack.freqs.plot(p.out,my.title="r=0.05")
dev.copy2pdf(file="~/Dropbox/Courses/Popgen_teaching_Notes/figures/selection_recom_interaction/Neutral_Hitchhiking.pdf")
###Deleterious allele Hitchhiking
par(mar=c(4,4.1,3,1))
n.gens<-1000
p<-  c(0.001,0.099,0,0.9); names(p)<-c("AB","Ab","aB","ab")
w.add<-c(0.97,0.93,1,0.95);names(w.add)<-names(p)
w.mat<-outer(w.add,w.add,FUN="+")
layout(t(1:3))
p.out<-two.loc.sims(p,w.mat,r=0.00);stack.freqs.plot(p.out,my.title="r=0.0");
p.out<-two.loc.sims(p,w.mat,r=0.000005);stack.freqs.plot(p.out,my.title="r=0.000005");
p.out<-two.loc.sims(p,w.mat,r=0.0002);stack.freqs.plot(p.out,my.title="r=0.0005");
dev.copy2pdf(file="~/Dropbox/Courses/Popgen_teaching_Notes/figures/Deleterious_Hitchhiking.pdf")
##interference
layout(t(1:2))
n.gens<-1000
p<-  c(0.0,0.01,0.01,0.98); names(p)<-c("AB","Ab","aB","ab")
w.add<-c(1.14,1.08,1.06,1);names(w.add)<-names(p)
w.mat<-outer(w.add,w.add,FUN="+")
p.out<-two.loc.sims(p,w.mat,r=0.00)
stack.freqs.plot(p.out)
p<-  c(0.0,0.01,0.01,0.98); names(p)<-c("AB","Ab","aB","ab")
w.add<-c(1.1,1.06,1.055,1);names(w.add)<-names(p)
w.mat<-outer(w.add,w.add,FUN="+")
p.out<-two.loc.sims(p,w.mat,r=0.001)
stack.freqs.plot(p.out)
dev.copy2pdf(file="~/Dropbox/Courses/Popgen_teaching_Notes/figures/Interference.pdf")
###synergistic alleles & recom
n.gens<-200
layout(t(1:3))
setwd("C:/Users/Mason Kulbaba/Dropbox/Rscripts/chamaecrista-adaptive-capacity/bootstrap/CS/2016")
# load packages
library(aster)
# load raster output
load("rout2016.RData")
# load redata file
load("redata2016.RData")
# load modmat.siredam matrix
load("modmat.siredam2016.RData")
modmat.siredamCS<- as.matrix(modmat.siredam2016)
load("doubleboot_CS2016_run.RData")
# Generate Va(W) from data
CS_Va.hat <- VaW(rout2016) # generates Va(W) from data
# calculate t for IQR-based confidence interval
t <- (CS_Va.star - CS_Va.hat) / se.CS_Va.star
# set confidence level
conf.level <- 0.95
# generate critical values with t for IQR-based confidence interval
crit <- quantile(t, probs = c((1 - conf.level) / 2, (1 + conf.level) / 2))  # note this uses the t just calculated
# generate IQR and standard deviation measures of scale
foo <- CS_Va.star[1:nboot]    # the outer loop Va's
se.CS_Va.hat <- diff(sort(foo)[c(25,76)])  # middle 50 percent of 100 or so
se.CS_Va.hat_sd <- sd(foo)  # standard deviation calculation of scale
# Conf. Int. for CS_Va with IQR scale metric
CS_Va.hat - rev(crit) * se.CS_Va.hat
# calculate t for standard deviation-based confidence interval
t <- (CS_Va.star - CS_Va.hat) / se.CS_Va.star_sd
# generate critical values with t for standard deviation-based confidence interval
crit <- quantile(t, probs = c((1 - conf.level) / 2, (1 + conf.level) / 2))
# Conf. Int. for CS_Va with standard deviation scale metric
CS_Va.hat - rev(crit) * se.CS_Va.hat_sd
CS_Va.star
length(CS_Va.star)
length(CS_Va.star.star)
CS_Va.star.star
