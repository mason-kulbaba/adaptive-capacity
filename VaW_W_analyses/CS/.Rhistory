moom[1 , 2]
moom <- goom[ , 3]
moom <- matrix(moom, ncol = 5)
moom[1874, 5]
4 * moom[1874, 5]^2 * rout2015$nu[1]
moom <- goom[ , 5]
moom <- matrix(moom, ncol = 5)
moom[1874, 5]
4 * moom[1874, 5]^2 * rout2015$nu[1]
sout
4*moom[1874 ,5]^2 * sout$nu["parental", "Std. Error"]/1.11
fisher <- sout$fisher
eout <- eigen(fisher, symmetric = TRUE)
fisher.inv <- eout$vectors %*% diag(1/eout$values) %*% t(eout$vectors)
dim(fisher)
dim(fisher.inv)
length(rout2015$alpha)
length(rout2015$nu)
#check - NOTE: changed from [6, 6] that was in Charlie's origional code
sqrt(fisher.inv[13, 13])
#good are the same
sout$nu["parental", "Std. Error"]
ioom <- seq(along = hoom$fit)
ioom <- matrix(ioom, ncol = 5)
idx <- ioom[1874, 5]
idx
g <- hoom$gradient[idx, ]
#check
predict(rout2015$obj, newcoef = rout2015$alpha, se.fit = TRUE)$se.fit[idx]
sqrt(t(g) %*% solve(rout2015$obj$fisher) %*% g)
#apply delta method for predicted change in fitness
g <- c(g, 0, 0)
xi.hat <- rout2015$nu[1]
eta.hat <- foom[1874, 5]
v.nu <- fisher.inv[13, 13]
v.meanfit <- t(g) %*% fisher.inv %*% g
v.nu.meanfit <- (fisher.inv %*% g)[13]
dim(t(g))
dim(fisher.inv)
dim(g)
g
dim(idx)
length(idz)
length(idx)
idx
hoom <- predict(rout2015$obj, newcoef = rout2015$alpha, gradient = TRUE)
goom <- hoom$gradient
moom <- goom[ , 5]
moom <- matrix(moom, ncol = 5)
moom[1874, 5]
#very close
4 * moom[1874, 5]^2 * rout2015$nu[1]
#Standard Error for predicted change in fitness
sout<- summary(rout2015)
sout
4*moom[1874 ,5]^2 * sout$nu["parental", "Std. Error"]/1.11
bhat<- rout2016$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2016$obj, newcoef = rout2016$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[11]= block6),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2016$alpha
alpha[11] <- alpha[11] + b #block 6 effects
hoom <- predict(rout2016$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[2274, 5])#first individual in block 6, fifth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
GC_b2016<- bhat.sireGC.mu
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
gc2016den<- density(bhat.sireGC.mu)
GC2016_den<- cbind(gc2016den[[1]], gc2016den[[2]])
#write.csv(GC2016_den, "gc2016den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2016$obj, newcoef = rout2016$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
GC_Va<- 4*moom[2274 ,5]^2 * rout2016$nu[1]/map(0)
GC_Va #0.83021
GC_Va/0.64
sout<-summary(rout2016)
4*moom[2274 ,5]^2 * sout$nu["parental", "Std. Error"]/1.11
bhat<- rout2017$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2017$obj, newcoef = rout2017$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[12]= block7),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2017$alpha
alpha[12] <- alpha[12] + b #block 7 effects
hoom <- predict(rout2017$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[3126, 5])#first individual in block 7, fourth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
GC_b2017<- bhat.sireGC.mu
GCb<- rbind(GC_b2015, GC_b2016, GC_b2017)
#write.table(GCb, "GCb_threeyears.csv", sep=",")
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
gc2017den<- density(bhat.sireGC.mu)
GC2017_den<- cbind(gc2017den[[1]], gc2017den[[2]])
#write.csv(GC2017_den, "gc2017den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2017$obj, newcoef = rout2017$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
GC_Va<- 4*moom[3126 ,5]^2 * rout2017$nu[1]/map(0)
GC_Va #6.49131
sout<-summary(rout2017)
GC_Va/1.06
4*moom[3126 ,5]^2 * sout$nu["parental", "Std. Error"]/1.06
bhat<- rout2016$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2016$obj, newcoef = rout2016$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[11]= block6),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2016$alpha
alpha[11] <- alpha[11] + b #block 6 effects
hoom <- predict(rout2016$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[2274, 5])#first individual in block 6, fifth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
GC_b2016<- bhat.sireGC.mu
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
gc2016den<- density(bhat.sireGC.mu)
GC2016_den<- cbind(gc2016den[[1]], gc2016den[[2]])
#write.csv(GC2016_den, "gc2016den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2016$obj, newcoef = rout2016$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
GC_Va<- 4*moom[2274 ,5]^2 * rout2016$nu[1]/map(0)
GC_Va #0.83021
#recall mean fitness in 2016 = 0.64
#Predicted change in fitness
GC_Va/0.64
sout<-summary(rout2016)
4*moom[2274 ,5]^2 * sout$nu["parental", "Std. Error"]/0.64
getwd
getwd()
setwd(""C:/Users/Mason Kulbaba/Dropbox/git/adaptive-capacity/VaW_W_analyses/KW")
setwd("C:/Users/Mason Kulbaba/Dropbox/git/adaptive-capacity/VaW_W_analyses/KW")
load(file="rout2015.RData")
#2016 reaster data
load(file="rout2016.RData")
#2017 reaster data
load(file="rout2017.RData")
library(aster)
#########################
#Estimate Va(W) for 2015#
#########################
#extract bhat - the estimates of random effects
bhat<- rout2015$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2015$obj, newcoef = rout2015$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[9]= block4),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2015$alpha
alpha[9] <- alpha[9] + b #block 4 effects
hoom <- predict(rout2015$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[1570, 5])# individual in block 4, fourth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
kw_b2015<- bhat.sireGC.mu
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
kw2015den<-density(bhat.sireGC.mu)
kw2015den<- cbind(kw2015den[[1]], kw2015den[[2]])
write.csv(kw2015den, "kw2015den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2015$obj, newcoef = rout2015$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
KW_Va2015<- 4*moom[1570 ,5]^2 * rout2015$nu[1]/map(0)
KW_Va2015 #3.
sout<-summary(rout2015)
#predicted change in fitness
KW_Va2015/3.02
#standard error for pred. change in fitness
4*moom[1570 ,5]^2 * sout$nu["parental", "Std. Error"]/3.02
bhat<- rout2016$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2016$obj, newcoef = rout2016$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[10]= block5),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2016$alpha
alpha[10] <- alpha[10] + b #block 5 effects
hoom <- predict(rout2016$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[2251, 5])# individual in block 5, fourth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
kw_b2016<- bhat.sireGC.mu
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
kw2016den<- density(bhat.sireGC.mu)
kw2016den<- cbind(kw2016den[[1]], kw2016den[[2]])
write.csv(kw2016den, "kw2016den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2016$obj, newcoef = rout2016$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
KW_Va2016<- 4*moom[2251 ,5]^2 * rout2016$nu[1]/map(0)
KW_Va2016
sout<- summary(rout2016)
KW_Va2016/1.88
#standard error for predicted change in fitness
4*moom[2251 ,5]^2 * sout$nu["parental", "Std. Error"]/1.88
#extract bhat - the estimates of random effects
bhat<- rout2017$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2017$obj, newcoef = rout2017$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[11]= block6),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2017$alpha
alpha[11] <- alpha[11] + b #block 6 effects
hoom <- predict(rout2017$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[2302, 5])# individual in block 6, fourth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
kw_b2017<- bhat.sireGC.mu
kw_bs<- rbind(kw_b2015, kw_b2016, kw_b2017)
write.table(kw_bs, file="KWb_threeyears.csv", sep=",")
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
kw2017den<- density(bhat.sireGC.mu)
kw2017den<- cbind(kw2017den[[1]], kw2017den[[2]])
write.csv(kw2017den, "kw2017den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2017$obj, newcoef = rout2017$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
KW_Va2017<- 4*moom[2303 ,5]^2 * rout2017$nu[1]/map(0)
KW_Va2017
sout<-summary(rout2017)
#predicted change in fitness
KW_Va2017/1.08
#standard error
4*moom[2303 ,5]^2 * sout$nu["parental", "Std. Error"]/1.08
hoom <- predict(rout2017$obj, newcoef = rout2017$alpha, gradient = TRUE)
goom <- hoom$gradient
moom <- goom[ , 5]
moom <- matrix(moom, ncol = 5)
moom[2303 , 5]
moom <- goom[ , 11]
moom <- matrix(moom, ncol = 5)
moom[2303 , 5]
4 * moom[2303 , 5]^2 * rout$nu[1]
4 * moom[2303 , 5]^2 * rout2015$nu[1]
4 * moom[2303 , 5]^2 * rout2017$nu[1]
moom <- goom[ , 3]
moom <- matrix(moom, ncol = 5)
moom[2303 , 5]
4 * moom[2303 , 5]^2 * rout2017$nu[1]
moom <- goom[ , 11]
moom <- matrix(moom, ncol = 5)
moom[2303 , 5]
4 * moom[2303 , 5]^2 * rout2017$nu[1]
moom <- goom[ , 5]
moom <- matrix(moom, ncol = 5)
moom[2303 , 5]
4 * moom[2303 , 5]^2 * rout2017$nu[1]
4 * moom[2303,5]^2 * sout$nu["sire", "Std. Error"]
4 * moom[2303,5]^2 * sout$nu["parental", "Std. Error"]
getwd()
setwd("C:/Users/Mason Kulbaba/Dropbox/git/adaptive-capacity/VaW_W_analyses/CS")
getwd()
#2015 reaster data
load(file="rout2015.RData")
#2016 reaster data
load(file="rout2016.RData")
#2017 reaster data
load(file="rout2017.RData")
library(aster)
#########################
#Estimate Va(W) for 2015#
#########################
#extract bhat - the estimates of random effects
bhat<- rout2015$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2015$obj, newcoef = rout2015$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[6]= block1),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2015$alpha
alpha[6] <- alpha[6] + b #block 1 effects
hoom <- predict(rout2015$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[1, 5])# individual in block 1, fifth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
cs_b2015<- bhat.sireGC.mu
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
cs2015den<-density(bhat.sireGC.mu)
cs2015den<- cbind(cs2015den[[1]], cs2015den[[2]])
write.csv(cs2015den, "cs2015den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2015$obj, newcoef = rout2015$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
CS_Va2015<- 4*moom[1 ,5]^2 * rout2015$nu[1]/map(0)
CS_Va2015
sout<- summary(rout2015)
#predicted change in fitness
CS_Va2015/1.80
#standard error for predicted change in fitness
4*moom[1 ,5]^2 * sout$nu["parental", "Std. Error"]/1.80
bhat<- rout2016$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2016$obj, newcoef = rout2016$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[7]= block2),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2016$alpha
alpha[7] <- alpha[7] + b #block 2 effects
hoom <- predict(rout2016$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[251, 5])# individual in block 2, fifth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
cs_b2016<- bhat.sireGC.mu
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
cs2016den<- density(bhat.sireGC.mu)
cs2016den<- cbind(cs2016den[[1]], cs2016den[[2]])
hoom<- predict(rout2016$obj, newcoef = rout2016$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
CS_Va2016<- 4*moom[251 ,5]^2 * rout2016$nu[1]/map(0)
CS_Va2016 #0.8562831
sout<-summary(rout2016)
4*moom[251 ,5]^2 * sout$nu["parental", "Std. Error"]/0.73
bhat<- rout2017$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)#the canonical estimates "look" somewhat normal...as they should
hoom <- predict(rout2017$obj, newcoef = rout2017$alpha)
hoom<- matrix(hoom, ncol =5)
hoom<- hoom[ , 5]
#add a component of b_hat that we want to map to the mean value
#parameter scale (from canoonical scale) to fit:block1 fixed effect (alpha[8]= block3),
#predict, and take value of fourth node for first indiv.
map <- function(b) {
stopifnot(length(b) == 1)
stopifnot(is.finite(b))
alpha <- rout2017$alpha
alpha[8] <- alpha[8] + b #block 3 effects
hoom <- predict(rout2017$obj, newcoef = alpha)
hoom <- matrix(hoom, ncol = 5)
return(hoom[971, 5])# individual in block 3, fifth node
}
#vectorize mapping function
fred<- Vectorize(map)
#plot the curve
curve(fred, from = -1 / 2, to = 1/2, xlab="b", ylab=expression(mu(b)))
#use the mapping function "fred" to convert the sire effects from the
#canonical to mean-value parameter scale
bhat.sireGC.mu<- fred(bhat.sire)
cs_b2017<- bhat.sireGC.mu
cs_bs<- rbind(cs_b2015, cs_b2016, cs_b2017)
write.table(cs_bs, file="CSb_threeyears.csv", sep=",")
stem(bhat.sireGC.mu)#no longer normal as expected
#generate probability density distribution
cs2017den<- density(bhat.sireGC.mu)
cs2017den<- cbind(cs2017den[[1]], cs2017den[[2]])
write.csv(cs2017den, "cs2017den.csv", quote = FALSE, row.names = FALSE)
hoom<- predict(rout2017$obj, newcoef = rout2017$alpha, se.fit=TRUE)
goom <- hoom$gradient
moom<- goom[,5]
moom<- matrix(moom, ncol=5)
#this is additive genetic variation for fitness!
CS_Va2017<- 4*moom[971 ,5]^2 * rout2017$nu[1]/map(0)
CS_Va2017
sout<-summary(rout2017)
#predicted chagne in fitness
CS_Va2017/1.24
#standard error of prediction
4*moom[971 ,5]^2 * sout$nu["parental", "Std. Error"]/1.24
