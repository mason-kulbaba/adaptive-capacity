K=rel3, max.iter=100)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
K=rel3, max.iter=100)
out
data(LDV)
head(LDV)
data(K_atwell)
head(K_atwell)
out1 <- marker_h2(data.vector=LDV$LDV,geno.vector=LDV$genotype,
covariates=LDV[,4:8],K=K_atwell)
out1
out1 <- marker_h2(data.vector=LDV$LDV,geno.vector=LDV$genotype,
covariates=LDV[,4:8],K=K_atwell)
out1
head(LDV)
rel<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/Delphinium_current_2021/r heritability/LDH_rel.csv")
#remove X in col names
new.names<- gsub("X", "", colnames(rel))
#set row names
colnames(rel)<- new.names
#set col names
rel2 <- rel[,-1]
rownames(rel2) <- rel[,1]
head(rel2)
rel3<- as.matrix(rel2)
delph<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/Delphinium_current_2021/r heritability/delphR.csv")
#first col to rownames
delph2 <- delph[,-1]
rownames(delph2) <- delph[,1]
head(delph2)
dim(delph2)
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
covariates=delph2[,4],   K=rel3, max.iter=100)
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
covariates=delph2$maxpos,   K=rel3, max.iter=100)
?marker_h2
class(delph2$maxpos)
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
covariates=delph2$maxpos,K=rel3)
delph<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/Delphinium_current_2021/r heritability/delphR.csv")
#first col to rownames
delph2 <- delph[,-1]
rownames(delph2) <- delph[,1]
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-06,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-06,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-12,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-18,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-16,  covariates=delph2$maxpos,K=rel3)
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-15,  covariates=delph2$maxpos,K=rel3)
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-14,  covariates=delph2$maxpos,K=rel3)
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-13,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-5,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-5,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-5,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 5,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 55,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 55,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps = 1e-6,  covariates=delph2$maxpos,K=rel3)
out
out <- marker_h2(data.vector= delph2$maxpos, geno.vector=delph2$genotype,
eps = 1e-6,  K=rel3)
out
out <- marker_h2(data.vector= delph2$maxpos, geno.vector=delph2$genotype,
eps = 1e-6,  K=rel3)
out
summary(delph2$est2)
delph2$est3<- delph2$est2 + .36375
summary(delph2$est3)
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
eps = 1e-6,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
eps = 1e-6,  K=rel3)
out
summary(delph2$est2)
delph2$est3<- delph2$est2 + .36376
summary(delph2$est3)
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
eps = 1e-6,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
eps = 1e-6,  K=rel3)
out
out <- marker_h2(data.vector= delph2$maxpos, geno.vector=delph2$genotype,
eps = 1e-6,  K=rel3)
out
summary(delph2$maxpos)
100*(27.9749/(27.82^2))
delph<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/Delphinium_current_2021/r heritability/delphR.csv")
#first col to rownames
delph2 <- delph[,-1]
rownames(delph2) <- delph[,1]
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
eps = 1e-6,  K=rel3)
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
eps = 1e-12,  K=rel3)
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
K=rel3)
out
out
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
K=rel3)
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
eps = 1000,  K=rel3)
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
max.iter = 1000,  K=rel3)
out
delph<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/Delphinium_current_2021/r heritability/delphR.csv")
#first col to rownames
delph2 <- delph[,-1]
rownames(delph2) <- delph[,1]
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
max.iter = 100,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est3, geno.vector=delph2$genotype,
max.iter = 100,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
max.iter = 100,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
max.iter = 100,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-10,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-10,      covariates=delph2$maxpos,  K=rel3)
out
library(heritability)
rel<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/Delphinium_current_2021/r heritability/LDH_rel.csv")
#remove X in col names
new.names<- gsub("X", "", colnames(rel))
#set row names
colnames(rel)<- new.names
#set col names
rel2 <- rel[,-1]
rownames(rel2) <- rel[,1]
head(rel2)
rel3<- as.matrix(rel2)
delph<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/Delphinium_current_2021/r heritability/delphR.csv")
#first col to rownames
delph2 <- delph[,-1]
rownames(delph2) <- delph[,1]
out <- marker_h2(data.vector= delph2$est, geno.vector=delph2$genotype,
eps=1e-10,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est, geno.vector=delph2$genotype,
eps=1e-10,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est, geno.vector=delph2$genotype,
eps=1e-12,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est, geno.vector=delph2$genotype,
eps=1e-12,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-12,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-12,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-12,      covariates=delph2$maxpos,  K=rel3)
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-11,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-11,      covariates=delph2$maxpos,  K=rel3)
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-10,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-10,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-12,      covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-12,  max.iter=500,    covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-12,  max.iter=500,    covariates=delph2$maxpos,  K=rel3)
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-12,  max.iter=500,    covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-12,  max.iter=500,    covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-12,  max.iter=500,    covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-12,  max.iter=500,    covariates=delph2$maxpos,  K=rel3)
out
?AI_algorith
??AI_algorith
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-10,  max.iter=500,    covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-10,  max.iter=500,    covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-10,  max.iter=500,    covariates=delph2$maxpos,  K=rel3)
out
out <- marker_h2(data.vector= delph2$est2, geno.vector=delph2$genotype,
eps=1e-10,  max.iter=500,    covariates=delph2$maxpos,  K=rel3)
out
?rnorm
range<- seq(-3:2, by=0.1)
?seq
range<- seq(from =-3, to=3, by=0.1)
range
function(x) <- x^3 + p*x
fun<- function(x) x^3 + p*x
fun
x<- seq(from =-3, to=3, by=0.1)
plot(fun(x))
x<- seq(from =-3, to=3, by=0.01)
fun<- function(x) x^3 + p*x
p=1
plot(fun(x))
p=2
plot(fun(x))
p=0.5
plot(fun(x))
p=0.1
plot(fun(x))
p=0.01
plot(fun(x))
p=0.000001
plot(fun(x))
p=1e-25
plot(fun(x))
p=-1
plot(fun(x))
p=-100
plot(fun(x))
p=-20
plot(fun(x))
p=-10
plot(fun(x))
x<- seq(from =-3, to=3, by=0.01)
fun<- function(x) x^3 + x^2 + x
p=-10
plot(fun(x))
fun<- function(x) x^3 + x^2 + x + p
p=0.5
plot(fun(x))
fun<- function(x) x^3 + x^2 + x
p=0.5
plot(fun(x))
head(dat)
rm(list=ls())
getwd()
setwd("C:/Users/Mason Kulbaba/Dropbox/git/adaptive-capacity/Revised/CS")
csdat<- read.csv("csdata.csv")
#divide into year-specific files
cs2015<- subset(csdat, year==2015)
cs2016<- subset(csdat, year==2016)
cs2017<- subset(csdat, year==2017)
#drop unused levels
cs2015<- droplevels(cs2015)
cs2016<- droplevels(cs2016)
cs2017<- droplevels(cs2017)
###################################################################################
# 1. Estimate mean expected fitness in greenhouse genration for 2015 and 2016 year#
###################################################################################
#isolate greenhouse generation from 2016 and 2017 data (only greenhouse cohort in 2015)
cs2016<- subset(cs2016, cohort=="greenhouse")
cs2016<- droplevels(cs2016)
cs2017<- subset(cs2017, cohort=="greenhouse")
cs2017<- droplevels(cs2017)
#make sure maternalID and paternalID is a factor
cs2015$maternalID<- as.factor(cs2015$maternalID)
cs2015$paternalID<- as.factor(cs2015$paternalID)
cs2016$maternalID<- as.factor(cs2016$maternalID)
cs2016$paternalID<- as.factor(cs2016$paternalID)
cs2017$maternalID<- as.factor(cs2017$maternalID)
cs2017$paternalID<- as.factor(cs2017$paternalID)
#set response variables -> these represent variables in graphical model
vars<- c("Germ","flw","total.pods", "total.pods.collected", "totalseeds")
#reshape data so that all response variables are located in a single vector in a new data
#set called "redata"
redata2015 <- reshape(cs2015, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
redata2016 <- reshape(cs2016, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
redata2017 <- reshape(cs2017, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
#Designation of fitness variable for 2015 data
fit <- grepl("totalseeds", as.character(redata2015$varb))
fit<- as.numeric(fit)
redata2015$fit <- fit
#check
with(redata2015, sort(unique(as.character(varb)[fit == 0])))
with(redata2015, sort(unique(as.character(varb)[fit == 1])))
#add a variable "root" to redata files, where value is 1
redata2015<- data.frame(redata2015, root=1)
redata2016<- data.frame(redata2016, root=1)
#make sure block, row, and position are factors
redata2015$block<- as.factor(redata2015$block)
redata2015$row<- as.factor(redata2015$row)
redata2015$position<- as.factor(redata2015$position)
redata2016$block<- as.factor(redata2016$block)
redata2016$row<- as.factor(redata2016$row)
redata2016$position<- as.factor(redata2016$position)
#load aster package
library(aster)
#set graphical mode and dist. for fitness nodes (preds)
pred<- c(0,1,2,3,4)
fam<- c(1,1,2,1,2)
#describe dist. of preds.
sapply(fam.default(), as.character)[fam]
#Designate fitness variable for 2016 data
fit <- grepl("totalseeds", as.character(redata2016$varb))
fit<- as.numeric(fit)
#Designation of fitness variable for 2017 data
fit <- grepl("totalseeds", as.character(redata2017$varb))
fit<- as.numeric(fit)
redata2017$fit <- fit
#check
with(redata2017, sort(unique(as.character(varb)[fit == 0])))
with(redata2017, sort(unique(as.character(varb)[fit == 1])))
#add a variable "root" to redata files, where value is 1
redata2017<- data.frame(redata2017, root=1)
#make sure block, row, and position are factors
redata2017$block<- as.factor(redata2017$block)
redata2017$row<- as.factor(redata2017$row)
redata2017$position<- as.factor(redata2017$position)
#check
with(redata2017, sort(unique(as.character(varb)[fit == 0])))
with(redata2017, sort(unique(as.character(varb)[fit == 1])))
#############################################################################
# 2. Reaster analyses for 2015, 2016, and 2017 greenhouse cohort. For clarity, the
#    actual calculation of Va(W) will be performed in a different script (Vaw_Calculation.R).
####combine maternal and paternal into a single parental effect to be estimated
modmat.sire2015 <- model.matrix(~ 0 + fit:paternalID, redata2015)
modmat.dam2015 <- model.matrix(~ 0 + fit:maternalID, redata2015)
modmat.siredam2015 <- cbind(modmat.sire2015,modmat.dam2015)
modmat.sire2016 <- model.matrix(~ 0 + fit:paternalID, redata2016)
modmat.dam2016 <- model.matrix(~ 0 + fit:maternalID, redata2016)
modmat.siredam2016 <- cbind(modmat.sire2016,modmat.dam2016)
modmat.sire2017 <- model.matrix(~ 0 + fit:paternalID, redata2017)
modmat.dam2017 <- model.matrix(~ 0 + fit:maternalID, redata2017)
modmat.siredam2017 <- cbind(modmat.sire2017,modmat.dam2017)
load("rout2015b_sub.RData")
sum.2015<- summary(rout2015b_sub)
sum.2015
#######################################################################################
#pulls up the fixed effect aster model needed for predict.aster
class(rout2015b_sub$obj)
bhat <- rout2015b_sub$b
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#21 sires
length(bhat.sire)
#extract bhat - the estimates of random effects
bhat<- rout2015b_sub$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)
# This is the revised mapping function to *properly* account for subsampling
map_factory <- function(rout) {
stopifnot(inherits(rout, "reaster"))
alpha <- rout$alpha
# modmat for one individual
modmat <- rout$obj$modmat[1, ,  , drop = FALSE] # first indiv. in block1A
# set root = 1
root <- array(1, dim = dim(modmat)[1:2])
is.subsampling <- grepl("total.pods.collected", vars) # remove subsample node?
function (b) {
stopifnot(is.numeric(b))
stopifnot(length(b) == 1)
if (! is.finite(b)) return(NaN)
alpha["fit"] <- alpha["fit"] + b # should these also correspond to fit"block1A, too?
# predict.aster doesn't use argument x when is.always.parameter = TRUE
# but it still checks x.  So x must be supplied and valid even though
# it does not affect the result.
xi <- try(predict(rout$obj, newcoef = alpha, modmat = modmat,
root = root, model.type = "conditional",
is.always.parameter = TRUE, x = root), silent = TRUE)
if (inherits(xi, "try-error")) return(NaN)
return(prod(xi[! is.subsampling]))
}
}
map <- map_factory(rout2015b_sub)
#Be sure to vectorize the map function
vectorized.map <- Vectorize(map)
#produce breeding values on the mean value parameter scale
bhat.sire.mu <- vectorized.map(bhat.sire)
curve(vectorized.map, from = -1/4, to = 1/4,
xlab="b", ylab=expression(mu(b)))
plot(density(bhat.sire.mu), main = "", xlab = "total seeds") # x-axis seems to have very large values
cs.2015<- bhat.sire.mu
cs.2015<- cs.2015[2:21]
# Calculate Va(W)
integrand_factory <- function(rout) {
stopifnot(inherits(rout, "reaster"))
sigma <- as.numeric(rout$sigma) * 2
function (b) {
stopifnot(is.numeric(b))
foo <- vectorized.map(b) * b * dnorm(b, sd = sigma)
foo[is.na(foo)] <- 0
return(foo)
}
}
integrand <- integrand_factory(rout2015b_sub)
iout <- integrate(integrand, lower = -Inf, upper = Inf)
iout$message
iout$value
# cov(m(Z), Z)^2 / var(Z)
vaw.hat <- iout$value^2 / environment(integrand)$sigma^2
vaw.hat
cov(m(Z), Z)^2 / var(Z)
load("rout2016b_sub.RData")
#pulls up the fixed effect aster model needed for predict.aster
class(rout2016b_sub$obj)
bhat <- rout2016b_sub$b
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#21 sires
length(bhat.sire)
#extract bhat - the estimates of random effects
bhat<- rout2016b_sub$b
#extract the sire effects
bhat.sire<- bhat[grep("paternalID", names(bhat))]
#stem plot of bhat estimates
stem(bhat.sire)
# This is the revised mapping function to *properly* account for subsampling
map_factory <- function(rout) {
stopifnot(inherits(rout, "reaster"))
alpha <- rout$alpha
# modmat for one individual
modmat <- rout$obj$modmat[1, ,  , drop = FALSE] # 251 first indiv in block2B
modmat[ , , "fit:block2B"] <- 0
# set root = 1
root <- array(1, dim = dim(modmat)[1:2])
is.subsampling <- grepl("total.pods.collected", vars) # remove subsample node?
function (b) {
stopifnot(is.numeric(b))
stopifnot(length(b) == 1)
if (! is.finite(b)) return(NaN)
alpha["fit"] <- alpha["fit"] + b # should these also correspond to fit"block1A, too?
# predict.aster doesn't use argument x when is.always.parameter = TRUE
# but it still checks x.  So x must be supplied and valid even though
# it does not affect the result.
xi <- try(predict(rout$obj, newcoef = alpha, modmat = modmat,
root = root, model.type = "conditional",
is.always.parameter = TRUE, x = root), silent = TRUE)
if (inherits(xi, "try-error")) return(NaN)
return(prod(xi[! is.subsampling]))
}
}
map <- map_factory(rout2016b_sub)
#Be sure to vectorize the map function
vectorized.map <- Vectorize(map)
#produce breeding values on the mean value parameter scale
bhat.sire.mu <- vectorized.map(bhat.sire)
curve(vectorized.map, from = -1/4, to = 1/4,
xlab="b", ylab=expression(mu(b)))
plot(density(bhat.sire.mu), main = "", xlab = "total seeds") # x-axis seems to have very large values
cs.2016<- bhat.sire.mu
cs.2016<- cs.2016[2:21]
# Calculate Va(W)
integrand_factory <- function(rout) {
stopifnot(inherits(rout, "reaster"))
sigma <- as.numeric(rout$sigma) * 2
function (b) {
stopifnot(is.numeric(b))
foo <- vectorized.map(b) * b * dnorm(b, sd = sigma)
foo[is.na(foo)] <- 0
return(foo)
}
}
integrand <- integrand_factory(rout2016b_sub)
iout <- integrate(integrand, lower = -Inf, upper = Inf)
iout$message
iout$value
# cov(m(Z), Z)^2 / var(Z)
vaw.hat <- iout$value^2 / environment(integrand)$sigma^2
vaw.hat
